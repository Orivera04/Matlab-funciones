
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      -->
      <title>Introduction to the drawLA Toolbox</title>
      <meta name="generator" content="MATLAB 7.7">
      <meta name="date" content="2009-04-08">
      <meta name="m-file" content="drawLAInro"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head>
   <body>
      <div class="content">
         <h1>Introduction to the drawLA Toolbox</h1>
         <!--introduction-->
         <p>The drawLA Toolbox was created to facilitate visualization of some basic concepts of Linear Algebra. It is a collection of
            MATLAB functions for easy plotting of 2D/3D vectors, planes, lines and spheres, and... displaying matrix equations.
         </p>
         <!--/introduction-->
         <h2>Contents</h2>
         <div>
            <ul>
               <li><a href="#1">Optional requirements</a></li>
               <li><a href="#2">Toolbox content</a></li>
               <li><a href="#3">1. drawVector</a></li>
               <li><a href="#15">2. drawPlane</a></li>
               <li><a href="#17">3. drawSpan</a></li>
               <li><a href="#20">4. drawLine</a></li>
               <li><a href="#24">5. drawXLine and drawYLine</a></li>
               <li><a href="#27">6. drawCircle</a></li>
               <li><a href="#28">7. drawAxes</a></li>
               <li><a href="#32">8. drawSphere</a></li>
               <li><a href="#39">9. drawMesh</a></li>
               <li><a href="#45">10. dispMEq</a></li>
               <li><a href="#52">11. drawGraph</a></li>
               <li><a href="#54">Comments or bugs?</a></li>
            </ul>
         </div>
         <h2>Optional requirements<a name="1"></a></h2><pre>arrow.m         - draw a line with arrow head. Written by Erik Johnson.
                  Available at the MATLAB Central File Exchange: File ID # 278.
                  Required by drawAxes.m.</pre><h2>Toolbox content<a name="2"></a></h2>
         <p>There are 12 functions in the toolbox.</p>
         <p>10 of them produce 2D/3D plots of geometric objects:</p><pre>1.  drawVector  - Draw 2D/3D vector(s).
2.  drawPlane   - Draw 2D/3D plane.
3.  drawSpan    - Draw line(2D)/plane(3D) spanned by one (2D/3D) or two (3D) vectors.
4.  drawLine    - Draw 2D/3D line between two points.
5.  drawXLine   - Draw vertical line in xy-plane at given x value.
6.  drawYLine   - Draw horizontal line in xy-plane at given y value.
7.  drawCircle  - Draw circle(s) in a xy-plane plot.
8.  drawAxes    - Draw 2D/3D coordinate axes lines.
9.  drawSphere  - Draw unit 2D/3D sphere under a linear (affine) transformation.
10. drawMesh    - Plot a polygonal 2D/3D mesh.</pre><p>The other two are auxiliary functions for:</p><pre>11. dispMEq     - Formatted display of a matrix equation.
12. drawGraph   - Draw small directed graph with up to 6 nodes.</pre><p>Each function is provided with a help and examples of its usage, which can be displayed by typing <tt>help <i>function name</i></tt> in the command window. E.g., <tt>help drawPlane</tt>.
         </p>
         <p>The several detailed examples below provide a fast overview of the toolbox functionality.</p>
         <h2>1. drawVector<a name="3"></a></h2>
         <p><b>Example in 2D:</b> Let's draw a 2D vector <b>a</b> = [3 1]':
         </p><pre class="codeinput">a = [3 1]'
figure(1); clf;
drawVector(a);
title(<span class="string">'Plot a 2D vector with drawVector()'</span>)
</pre><pre class="codeoutput">
a =

     3
     1

</pre><img vspace="5" hspace="5" src="drawLAInro_01.png" alt=""> <p>Note the coordinate axes. They are added automatically.</p>
         <p>As you see, the default color of a vector is blue, the default marker type is a dot and the default line type is a line. You
            can easily change those parameters and plot a vector as a, say, single red square.
         </p><pre class="codeinput">drawVector(a, <span class="string">'rs'</span>);
title(<span class="string">'Plot a vector as a point'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_02.png" alt=""> <p>The following command adds a dotted line:</p><pre class="codeinput">drawVector(a, <span class="string">'rs-.'</span>);
title(<span class="string">'Use different line style'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_03.png" alt=""> <p>It is also possible to name the vector, specifying its label in the curly brackets, i.e., as a cell array:</p><pre class="codeinput">drawVector(a, <span class="string">'rs-'</span>, {<span class="string">'a'</span>});
title(<span class="string">'Draw a named vector'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_04.png" alt=""> <p>To draw a second vector, e.g., <b>b</b> = [-2 1]' one could use <tt>hold on</tt>:
         </p><pre class="codeinput">b = [-2 1]';
hold <span class="string">on</span>;
drawVector(b, {<span class="string">'b'</span>});
hold <span class="string">off</span>;
title(<span class="string">'Draw two vectors: possibility 1'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_05.png" alt=""> <p>But there is a nicer way to do that in one line:</p><pre class="codeinput">figure(1); clf;
drawVector([a b], <span class="string">'g-&gt;'</span>, {<span class="string">'a'</span>, <span class="string">'b'</span>});
title(<span class="string">'Draw two vectors: possibility 2'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_06.png" alt=""> <p>In a similar way, you can plot more vectors, just put them as columns into a matrix. E.g.:</p><pre class="codeinput">A = [ 2 3 1 ;
      4 1 1 ];
hV = drawVector(A, {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>});
title(<span class="string">'Draw several vectors at once'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_07.png" alt=""> <p><tt>drawVector</tt> returns an optional output - a handles structure, hV. This structure has three fields <tt>hV.p</tt>, <tt>hV.l</tt>, and <tt>hV.t</tt> which contain the handles of the vector points (markers), lines and labels (text), respectively.
         </p>
         <p>The handles may be used to change the plot appearance afterwards. E.g., the following  command change the line style of the
            first vector from the last example.
         </p><pre class="codeinput">set(hV.l(1), <span class="string">'LineStyle'</span>, <span class="string">'-.'</span>);
title(<span class="string">'Postprocessing of vector properties'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_08.png" alt=""> <p><b>Example in 3D:</b> You can draw 3D vectors in the completely similar way. Let's draw two random <b>3D</b> vectors: A = rand(<b>3</b>, 2)*2 - 1;
         </p><pre class="codeinput">A = rand(3, 2)*2 - 1;
figure(1); clf;
drawVector(A, {<span class="string">'a'</span>, <span class="string">'b'</span>});
view(60,10)
title(<span class="string">'Plot 3D vectors with drawVector()'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_09.png" alt=""> <p>Again the axes are added automatically. If you would like to have different axes labels pass them as a cell array with the
            optional parameter, 'AxesLabels':
         </p><pre class="codeinput">A = [ 1  1;
      2 -2
      3  3 ];
figure(1); clf;
drawVector(A, {<span class="string">'a'</span>, <span class="string">'b'</span>}, <span class="string">'AxesLabels'</span>, {<span class="string">'\alpha'</span>,<span class="string">'\beta'</span>,<span class="string">'\gamma'</span>});
view(60,10)
title(<span class="string">'Example of different axes labeling'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_10.png" alt=""> <h2>2. drawPlane<a name="15"></a></h2>
         <p>A plane is defined by a normal vector, <b>n</b>, that determines the plane's orientation and a scalar, <i>d</i>, that specifies the magnitude of a shift of the plane from the origin in the direction of <b>n</b>. For the given <b>n</b> and <i>d</i>, all the points (i.e., vectors <b>x</b>), satisfying the following equations belong to the plane:
         </p>
         <p><img src="drawLAInro_eq37012.png" alt="$$\mathbf{n\cdot x} + d = 0$$"></p>
         <p>With the function <tt>drawPlane()</tt>, you can easily visualize planes in 2 and 3 dimensions. Let's begin with a 3D case.
         </p>
         <p><b>3D example:</b></p><pre class="codeinput">n = [1 2 3]';
figure(1); clf; hold <span class="string">on</span>;
drawVector(n, {<span class="string">'n'</span>});       <span class="comment">% the normal</span>
drawPlane(n);               <span class="comment">% unshifted plane, comes through the origin</span>
drawPlane(n, 5, <span class="string">'r'</span>);       <span class="comment">% the plane shifted by "5"</span>
view(60,15)
hold <span class="string">off</span>;
title(<span class="string">'Plot 3D planes with drawPlane()'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_11.png" alt=""> <p><b>2D example:</b> In 2D, a plane is a straight line.
         </p><pre class="codeinput">n = [1 2]';
figure(1); clf; hold <span class="string">on</span>;
drawVector(n, {<span class="string">'n'</span>});       <span class="comment">% the normal</span>
drawPlane(n);               <span class="comment">% unshifted plane, comes through the origin</span>
drawPlane(n, 2, <span class="string">'r'</span>);       <span class="comment">% the plane shifted by "2"</span>
hold <span class="string">off</span>;
title(<span class="string">'Plot 2D planes with drawPlane()'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_12.png" alt=""> <h2>3. drawSpan<a name="17"></a></h2>
         <p>There is another possibility to specify a (hyper-)plane in an N-dimensional space: specify N-1 ND-vectors that will <b>span</b> the plane, i.e., vectors that lie in the plane. The <tt>drawSpan()</tt> routine visualizes planes in 2D and 3D defined in this way.
         </p>
         <p><b>Example in 3D</b>:
         </p><pre class="codeinput">a = [1 2 3]'; b = [1 1 1]';         <span class="comment">% Two 3D-vector</span>
figure(1);clf; hold <span class="string">on</span>;
drawVector([a b], {<span class="string">'a'</span>,<span class="string">'b'</span>});
drawSpan([a b], <span class="string">'b'</span>)
view(-40,5)
hold <span class="string">off</span>;
title(<span class="string">'Visualization of the span of two 3D vectors with drawSpan()'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_13.png" alt=""> <p><b>Note:</b> A plane, defined as vectors <i>span</i> always contains the origin. To put it in mathematical terms, it is a linear subspace. If you'd like to <i>shift</i> the plane, you'll have to compute its normal and use the <tt>drawPlane()</tt> function:
         </p><pre class="codeinput">n = cross(a,b);                     <span class="comment">% The normal</span>
figure(1);hold <span class="string">on</span>;
drawVector(n, {<span class="string">'n'</span>}, <span class="string">'g.-'</span>);
drawPlane(n, 4, <span class="string">'r'</span>)                <span class="comment">% Plot red plane</span>
view(-113,42)
hold <span class="string">off</span>;
title(<span class="string">'drawSpan vs. drawPlane()'</span>);
</pre><img vspace="5" hspace="5" src="drawLAInro_14.png" alt=""> <p><b>Example in 2D</b>: A span in 2D is defined by a single 2D-vector:
         </p><pre class="codeinput">a = [1 1];
figure(1); clf;
drawSpan(a);
title(<span class="string">'drawSpan() in 2D'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_15.png" alt=""> <h2>4. drawLine<a name="20"></a></h2>
         <p>As its name suggests, this function draws a line (2D or 3D) between two points (i.e., vectors). By default, the line type
            is dashed and its color is black but you can easily change it. Here is an example:
         </p>
         <p><b>Example in 2D</b>:
         </p><pre class="codeinput">a = [2 1]'; b = [3 -2]';            <span class="comment">% Two 2D-vectors</span>
figure(1);clf; hold <span class="string">on</span>;
drawVector([a b], {<span class="string">'a'</span>,<span class="string">'b'</span>});       <span class="comment">% Plot the vectors</span>
drawLine([a b]);                    <span class="comment">% Draw a line between them</span>
hold <span class="string">off</span>;
title(<span class="string">'Draw a line between two vectors with drawLine()'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_16.png" alt=""> <p>Change the line style (see <tt>help drawLine</tt>).
         </p><pre class="codeinput">figure(1);clf; hold <span class="string">on</span>;
drawVector([a b], {<span class="string">'a'</span>,<span class="string">'b'</span>});       <span class="comment">% Plot the vectors</span>
drawLine([a b], <span class="string">'r2-.'</span>);            <span class="comment">% Draw a line between them</span>
hold <span class="string">off</span>;
title(<span class="string">'Example of a different line style'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_17.png" alt=""> <p><b>Example in 3D</b>:
         </p><pre class="codeinput">a = [1 2 3]'; b = [3 -1 2]';        <span class="comment">% Two 3D-vectors</span>
figure(1);clf; hold <span class="string">on</span>;
drawVector([a b], {<span class="string">'a'</span>,<span class="string">'b'</span>});       <span class="comment">% Plot the vectors</span>
drawLine([a b], <span class="string">'r3'</span>);              <span class="comment">% Draw a line between them</span>
view(15,5);
hold <span class="string">off</span>;
title(<span class="string">'Draw a line in 3D with drawLine()'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_18.png" alt=""> <h2>5. drawXLine and drawYLine<a name="24"></a></h2>
         <p>These commands draw a vertical/horizontal line in the xy plane at a given x/y value:</p>
         <p>Vertical line:</p><pre class="codeinput">figure(1); clf;
drawVector([1 1]);
drawXLine(1,<span class="string">'r'</span>);
title(<span class="string">'Draw an x-line in the xy-plane'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_19.png" alt=""> <p>Horizontal line:</p><pre class="codeinput">figure(1); clf;
drawVector([1 1]);
drawYLine(1,<span class="string">'r'</span>);
title(<span class="string">'Draw an y-line in the xy-plane'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_20.png" alt=""> <p>These commands work also in 3D:</p><pre class="codeinput">figure(1); clf; drawVector([1 -1 2]/2);
<span class="keyword">for</span> x=-1:.2:1, drawXLine(x,<span class="string">'2r'</span>); <span class="keyword">for</span> y = -1:.2:1, drawYLine(y,<span class="string">'2r'</span>); <span class="keyword">end</span>, <span class="keyword">end</span>
title(<span class="string">'drawXLine() and drawYLine() in 3D'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_21.png" alt=""> <h2>6. drawCircle<a name="27"></a></h2>
         <p>This command draws a circle or several circles in the xy-plane.</p>
         <p>By default, it draws a black unit circle at the origin: <tt>drawCircle</tt>. The general usage is <tt>drawCircle(x,y,r,lineSpec)</tt>, where x, y, and r are matrices of the center coordinates (<tt>x</tt> and <tt>y</tt>) and radii (<tt>r</tt>) of the circles; <tt>lineSpec</tt> is a string argument defining the line type.
         </p>
         <p>The following examples illustrate the usage in 2D and 3D:</p><pre class="codeinput">figure(1); clf;
subplot(2,2,1); drawCircle;
title(<span class="string">'Draw a circle at the origin'</span>);
subplot(2,2,2); drawCircle(1,1,<span class="string">'rd'</span>);
title(<span class="string">'or set another circle center'</span>);
subplot(2,2,3); drawCircle(rand(5,1), rand(5,1), rand(5,1)/3, <span class="string">'2r-'</span>);
title(<span class="string">'Draw several circles at once'</span>)
subplot(2,2,4); drawPlane([0 0 1]); drawCircle(rand(5,1)*2-1, rand(5,1)*2-1, rand(5,1)/2, <span class="string">'2g-'</span>);
title(<span class="string">'Use of drawCircle() in 3D'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_22.png" alt=""> <h2>7. drawAxes<a name="28"></a></h2>
         <p><tt>drawAxes()</tt> is a function that is probably never to use directly, but which is called by almost all other functions in the toolbox. It
            plots into the current figure the "xy" (2D) or "xyz" (3D) coordinate axes lines going through the origin. It takes two mandatory
            parameters: a dimension number, d = {2,3}, and a string defining the axes color.
         </p>
         <p><b>Note:</b> to put the arrows at the end of coordinate lines, <tt>drawAxes()</tt> makes use of a 3d party function "arrow.m" if it is available under the MATLAB search path. The "arrow.m" was written by
            Erik Johnson and can be downloaded from the MATLAB Central File Exchange: <a href="http://www.mathworks.com/matlabcentral/fileexchange/278">www.mathworks.com/matlabcentral/fileexchange/278</a>.
         </p>
         <p><b>Example in 3D:</b></p><pre class="codeinput">load(<span class="string">'queen.mat'</span>);                      <span class="comment">% load the vertex and face arrays</span>
figure(1); clf;
drawMesh(vertex, face, <span class="string">'wire'</span>);         <span class="comment">% draw a 3D mesh</span>
drawAxes(3, <span class="string">'g'</span>);                       <span class="comment">% Draw green axes</span>
view(60, 10)
title(<span class="string">'drasAxes: draw green coordinate axes through the origin'</span>);
</pre><img vspace="5" hspace="5" src="drawLAInro_23.png" alt=""> <p>Sometimes you would like to have different axes labels instead of the standard "xyz". You can specify those by calling <tt>drawAxes</tt> with an additional (optional) parameter, a cell array of strings:
         </p><pre class="codeinput">figure(1); clf;
drawMesh(vertex, face, <span class="string">'wire'</span>);
drawAxes(3, <span class="string">'r'</span>, {<span class="string">'Axes 1'</span>,<span class="string">'Axes 2'</span>,<span class="string">'Axes 3'</span>}); <span class="comment">% Name axes</span>
view(60, 10)
title(<span class="string">'Different axes labeling'</span>);
</pre><img vspace="5" hspace="5" src="drawLAInro_24.png" alt=""> <p><b>Example in 2D:</b></p><pre class="codeinput">figure(1); clf;
plot(exp(2*pi*1i*(1:20)/20), <span class="string">'.'</span>);
drawAxes(2, <span class="string">'k'</span>, {<span class="string">'\alpha'</span>,<span class="string">'\beta'</span>});
title(<span class="string">'Draw coordinate axes in 2D'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_25.png" alt=""> <h2>8. drawSphere<a name="32"></a></h2>
         <p>This comman plot the unit 2D or 3D sphere under a linear transformation. By default, it draws the unit 3D sphere:</p><pre class="codeinput">figure(1); clf;
drawSphere
title(<span class="string">'Draw the unit sphere with drawSphere()'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_26.png" alt=""> <p>To plot the 2D sphere, which is a circle, specify a 2-by-2 transformation matrix, <b>A</b>. For the unit sphere, <b>A</b> should be the identity matrix:
         </p><pre class="codeinput">clf; drawSphere(eye(2),[1 1])
title(<span class="string">'Draw the 2D unit sphere'</span>);
</pre><img vspace="5" hspace="5" src="drawLAInro_27.png" alt=""> <p>A linear transformation transforms the unit sphere into an ellipsoid. Here is an example in 2D:</p><pre class="codeinput">clf; drawSphere([1 1; 0 -1], <span class="string">'r'</span>);
title(<span class="string">'Draw the 2D unit sphere under a linear transformation'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_28.png" alt=""> <p>Example in 3D:</p><pre class="codeinput">clf; drawSphere(magic(3),<span class="string">'g'</span>,.2); view([13 5]);
title(<span class="string">'Draw the 3D unit sphere under a linear transformation'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_29.png" alt=""> <p>Note the optional parameters: 'g' and .2, which are the sphere color and the transparency value, respectively.</p>
         <p>Actually, <tt>drawSphere</tt> allows to specify an <i>affine</i> transformation. That is, linear transformation + a shift. The shift vector is given as an additional (optional) input parameter:
         </p><pre class="codeinput">clf; drawSphere(rand(2)*2);                  <span class="comment">% linear transform</span>
hold <span class="string">on</span>; drawSphere(rand(2), [1 1]/2, <span class="string">'g'</span>);  <span class="comment">% affine transform</span>
title(<span class="string">'Linear and affine transforms of the unit sphere'</span>);
</pre><img vspace="5" hspace="5" src="drawLAInro_30.png" alt=""> <pre class="codeinput">clf; drawSphere(rand(3));                    <span class="comment">% linear transformation</span>
hold <span class="string">on</span>; drawSphere(rand(3), [1 0 1], <span class="string">'g'</span>);  <span class="comment">% affine transformation</span>
title(<span class="string">'Linear and affine transforms of the unit sphere'</span>);
</pre><img vspace="5" hspace="5" src="drawLAInro_31.png" alt=""> <h2>9. drawMesh<a name="39"></a></h2>
         <p>This function plots a 2D or 3D polygonal mesh. A "mesh" is defined by two arrays: <b>V</b> and <b>F</b>. The first one has the dimensions <i>n</i>-by-{2,3} and contains the 2D/3D coordinates of <i>n</i> "vertices". The second <i>m</i>-by-k array of "faces" defines the connectivity of the vertices: each of the <i>m</i> rows correspond to a face and contains the <i>indices</i> (i.e., positive integers) of the vertices incident with the face. Different faces can have different number of incident vertices,
            <i>k</i> is the maximum number of vertices among all the faces. The next examples clarify the issue:
         </p>
         <p><b>Example 1: 2D mesh</b></p><pre class="codeinput">load(<span class="string">'home.mat'</span>);                   <span class="comment">% Load the vertex and face arrays</span>
figure(1); clf;
drawMesh(vertex, face, <span class="string">'wire'</span>);     <span class="comment">% Plot the mesh</span>
axis <span class="string">on</span>; grid <span class="string">on</span>; axis([-.5 1.5 0 1.5])
title(<span class="string">'Draw a 2D mesh with drawMesh()'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_32.png" alt=""> <p><b>Example 2: 3D Surface plot</b></p><pre class="codeinput">load(<span class="string">'queen.mat'</span>);                  <span class="comment">% Load the vertex and face arrays</span>
figure(1); clf;
drawMesh(vertex, face)              <span class="comment">% Plot the mesh</span>
view(20, 60)
title(<span class="string">'Draw a 3D mesh with drawMesh()'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_33.png" alt=""> <p>Of course, you are free to change the color of the mesh:</p><pre class="codeinput">figure(1); clf;
drawMesh(vertex, face, <span class="string">'b'</span>)         <span class="comment">% Plot the mesh in blue color</span>
view(20, 60)
title(<span class="string">'Specify the mesh color'</span>);
</pre><img vspace="5" hspace="5" src="drawLAInro_34.png" alt=""> <p>... and change its transparency:</p><pre class="codeinput">figure(1); clf;
drawMesh(vertex, face, <span class="string">'b'</span>, .5)     <span class="comment">% Semitransparent mesh</span>
view(20, 60)
title(<span class="string">'Specify the mesh transparency'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_35.png" alt=""> <p><b>Example 3: 3D wire-frame plot</b></p><pre class="codeinput">figure(1); clf;
drawMesh(vertex, face, <span class="string">'wire'</span>)      <span class="comment">% wire-frame plot</span>
view(20, 60)
title(<span class="string">'Wire-frame plot of a mesh'</span>)
</pre><img vspace="5" hspace="5" src="drawLAInro_36.png" alt=""> <h2>10. dispMEq<a name="45"></a></h2>
         <p>This function was written to enhance the MATLAB publishing capabilities by the possibility to include matrix equations in
            a published file. In its simplest form, dispMEq can be used to visualize a matrix. E.g., to visualize a random matrix, <b>A</b>, use:
         </p><pre class="codeinput">figure(2); clf; dispMEq(<span class="string">'A'</span>, rand(5));
</pre><img vspace="5" hspace="5" src="drawLAInro_37.png" alt=""> <p>By default, the numbers are shown with 2 decimals after the comma. However, it is possible to specify a different numeric
            format with an option 'format':
         </p><pre class="codeinput">A = rand(5); figure(2);clf; dispMEq(<span class="string">'A'</span>, A, <span class="string">'format'</span>, {<span class="string">'%1.1f'</span>});
</pre><img vspace="5" hspace="5" src="drawLAInro_38.png" alt=""> <p>The following example shows how <tt>dispMEq</tt> can be used to visualize a proper matrix equation:
         </p><pre class="codeinput">A = rand(5); [L,U] = lu(A);
figure(3); clf; dispMEq(<span class="string">'A = L*U'</span>, A, L, U);
</pre><img vspace="5" hspace="5" src="drawLAInro_39.png" alt=""> <pre>or:</pre><pre class="codeinput">A = randn(5,3); x=rand(3,1); figure(2); clf; dispMEq(<span class="string">'A*x=b'</span>, A, x, A*x);
</pre><img vspace="5" hspace="5" src="drawLAInro_40.png" alt=""> <p>Beside the numeric format, dispMEq supports a kind of "symbolic" equations also. A symbolic representation is used automatically
            whenever the matrix elements are not numbers. Consider the following example:
         </p><pre class="codeinput">A = nan(5); x = nan(5,1); b = nan(5,1);
figure(2);clf; dispMEq(<span class="string">'A*x=b'</span>,A,x,b);
</pre><img vspace="5" hspace="5" src="drawLAInro_41.png" alt=""> <p>The default format in the symbolic mode is 'elems', meaning elementwise: each entry of a matrix is displayed as a symbol with
            appropriate subscript indices. However, there are two additional representation format options - 'rows' and 'cols' - which
            allow to group the elements accordingly. The following example illustrates the three possible symbolic representation forms:
         </p><pre class="codeinput">A = nan(5); figure(3);clf; dispMEq(<span class="string">'A;A;A'</span>,A,A,A,<span class="string">'format'</span>,{<span class="string">'elems'</span>,<span class="string">'cols'</span>,<span class="string">'rows'</span>});
</pre><img vspace="5" hspace="5" src="drawLAInro_42.png" alt=""> <p>Ultimately, <tt>dispMEq</tt> allows to specify a custom text displayed in each matrix in the equation. This can be achieved by defining the matrix as
            a cell array of strings, as in the next example:
         </p><pre class="codeinput">y = {<span class="string">'a^1\cdot x'</span>;
     <span class="string">'a^2\cdot x'</span>;
     <span class="string">'a^3\cdot x'</span>;
     <span class="string">'a^4\cdot x'</span>  };
figure(2);clf; dispMEq(<span class="string">'A*x=y'</span>,A,x,y,<span class="string">'format'</span>,{<span class="string">'rows'</span>, <span class="string">'cols'</span>,<span class="string">'rows'</span>})
</pre><img vspace="5" hspace="5" src="drawLAInro_43.png" alt=""> <h2>11. drawGraph<a name="52"></a></h2>
         <p>This is a toy function that plots a toy directed graph with up to 6 nodes, n, defined by its n-by-n adjacency matrix:</p><pre class="codeinput">G = toeplitz([0 1 0 0 0 0], [0 0 0 0 0 1])
figure(1); clf; drawGraph(G);
</pre><pre class="codeoutput">
G =

     0     0     0     0     0     1
     1     0     0     0     0     0
     0     1     0     0     0     0
     0     0     1     0     0     0
     0     0     0     1     0     0
     0     0     0     0     1     0

</pre><img vspace="5" hspace="5" src="drawLAInro_44.png" alt=""> <p><html> <hr> </html></p>
         <h2>Comments or bugs?<a name="54"></a></h2>
         <p>The toolbox was written by Vladimir Bondarenko for the <a href="http://sites.google.com/a/uni-konstanz.de/na09/">"Numerical algorithms"</a> course to visualize the geometric ideas central to the methods of numerical linear algebra.
         </p>
         <p>For comments, bugs and suggestions contact: <a href="http://sites.google.com/site/bondsite">Vladimir Bondarenko</a>.
         </p>
         <p class="footer"><br>
            Published with MATLAB&reg; 7.7<br></p>
      </div>
      <!--
##### SOURCE BEGIN #####
%% Introduction to the drawLA Toolbox
% The drawLA Toolbox was created to facilitate visualization of some basic
% concepts of Linear Algebra. It is a collection of MATLAB functions for easy
% plotting of 2D/3D vectors, planes, lines and spheres, and... displaying matrix
% equations.
%% Optional requirements
%  arrow.m         - draw a line with arrow head. Written by Erik Johnson.
%                    Available at the MATLAB Central File Exchange: File ID # 278.
%                    Required by drawAxes.m.
%% Toolbox content
% There are 12 functions in the toolbox. 
%
% 10 of them produce 2D/3D plots of geometric objects:
%
%  1.  drawVector  - Draw 2D/3D vector(s).
%  2.  drawPlane   - Draw 2D/3D plane.
%  3.  drawSpan    - Draw line(2D)/plane(3D) spanned by one (2D/3D) or two (3D) vectors.
%  4.  drawLine    - Draw 2D/3D line between two points.
%  5.  drawXLine   - Draw vertical line in xy-plane at given x value.
%  6.  drawYLine   - Draw horizontal line in xy-plane at given y value.
%  7.  drawCircle  - Draw circle(s) in a xy-plane plot.
%  8.  drawAxes    - Draw 2D/3D coordinate axes lines.
%  9.  drawSphere  - Draw unit 2D/3D sphere under a linear (affine) transformation.
%  10. drawMesh    - Plot a polygonal 2D/3D mesh.
%
% The other two are auxiliary functions for:
%
%  11. dispMEq     - Formatted display of a matrix equation.
%  12. drawGraph   - Draw small directed graph with up to 6 nodes.
%
% Each function is provided with a help and examples of its usage, which can be
% displayed by typing |help _function name_| in the command window. E.g., |help
% drawPlane|.
%
% The several detailed examples below provide a fast overview of the toolbox
% functionality. 
%% 1. drawVector
%% 
% *Example in 2D:*
% Let's draw a 2D vector *a* = [3 1]':
a = [3 1]'
figure(1); clf;
drawVector(a);
title('Plot a 2D vector with drawVector()')
%% 
% Note the coordinate axes. They are added automatically. 
%%
% As you see, the default color of a vector is blue, the default marker type
% is a dot and the default line type is a line. You can easily change those
% parameters and plot a vector as a, say, single red square.
drawVector(a, 'rs');
title('Plot a vector as a point')
%%
% The following command adds a dotted line:
drawVector(a, 'rs-.');
title('Use different line style')
%% 
% It is also possible to name the vector, specifying its label in the curly
% brackets, i.e., as a cell array:
drawVector(a, 'rs-', {'a'});
title('Draw a named vector')
%%
% To draw a second vector, e.g., *b* = [-2 1]' one could use |hold on|:
b = [-2 1]';
hold on;
drawVector(b, {'b'});
hold off;
title('Draw two vectors: possibility 1')
%%
% But there is a nicer way to do that in one line:
figure(1); clf;
drawVector([a b], 'g->', {'a', 'b'});
title('Draw two vectors: possibility 2')
%%
% In a similar way, you can plot more vectors, just put them as columns into a
% matrix. E.g.:
A = [ 2 3 1 ;
      4 1 1 ];
hV = drawVector(A, {'a', 'b', 'c'});
title('Draw several vectors at once')
%%
% |drawVector| returns an optional output - a handles structure, hV. This 
% structure has three fields |hV.p|, |hV.l|, and |hV.t| which contain the
% handles of the vector points (markers), lines and labels (text), respectively.
% 
% The handles may be used to change the plot appearance afterwards. E.g., the
% following  command change the line style of the first vector from the last
% example. 
set(hV.l(1), 'LineStyle', '-.');
title('Postprocessing of vector properties')
%% 
% *Example in 3D:*
% You can draw 3D vectors in the completely similar way.
% Let's draw two random *3D* vectors: A = rand(*3*, 2)*2 - 1; 
A = rand(3, 2)*2 - 1;
figure(1); clf;
drawVector(A, {'a', 'b'});
view(60,10)
title('Plot 3D vectors with drawVector()')
%%
% Again the axes are added automatically. If you would like to have different
% axes labels pass them as a cell array with the optional parameter,
% 'AxesLabels':
A = [ 1  1;
      2 -2
      3  3 ];
figure(1); clf;
drawVector(A, {'a', 'b'}, 'AxesLabels', {'\alpha','\beta','\gamma'});
view(60,10)
title('Example of different axes labeling')
%% 2. drawPlane
% A plane is defined by a normal vector, *n*, that determines the plane's
% orientation and a scalar, _d_, that specifies the magnitude of a shift of the
% plane from the origin in the direction of *n*. For the given *n* and _d_, all
% the points (i.e., vectors *x*), satisfying the following equations belong to
% the plane: 
%
% $$\mathbf{n\cdot x} + d = 0$$
%
% With the function |drawPlane()|, you can easily visualize planes in 2 and 3
% dimensions. Let's begin with a 3D case. 
%
% *3D example:*
n = [1 2 3]';
figure(1); clf; hold on;
drawVector(n, {'n'});       % the normal
drawPlane(n);               % unshifted plane, comes through the origin
drawPlane(n, 5, 'r');       % the plane shifted by "5"
view(60,15)
hold off;
title('Plot 3D planes with drawPlane()')
%%
% *2D example:*
% In 2D, a plane is a straight line.
n = [1 2]';
figure(1); clf; hold on;
drawVector(n, {'n'});       % the normal
drawPlane(n);               % unshifted plane, comes through the origin
drawPlane(n, 2, 'r');       % the plane shifted by "2"
hold off;
title('Plot 2D planes with drawPlane()')
%% 3. drawSpan
% There is another possibility to specify a (hyper-)plane in an N-dimensional
% space: specify N-1 ND-vectors that will *span* the plane, i.e., vectors that
% lie in the plane. The |drawSpan()| routine visualizes planes in 2D and 3D
% defined in this way. 
%
% *Example in 3D*:
a = [1 2 3]'; b = [1 1 1]';         % Two 3D-vector
figure(1);clf; hold on;
drawVector([a b], {'a','b'});
drawSpan([a b], 'b')
view(-40,5)
hold off;
title('Visualization of the span of two 3D vectors with drawSpan()')
%%
% *Note:* A plane, defined as vectors _span_ always contains the origin. To put it
% in mathematical terms, it is a linear subspace. If you'd like to _shift_ the
% plane, you'll have to compute its normal and use the |drawPlane()| function:
n = cross(a,b);                     % The normal
figure(1);hold on;
drawVector(n, {'n'}, 'g.-');
drawPlane(n, 4, 'r')                % Plot red plane
view(-113,42)
hold off;
title('drawSpan vs. drawPlane()');
%%
% *Example in 2D*:
% A span in 2D is defined by a single 2D-vector:
a = [1 1];
figure(1); clf;
drawSpan(a);
title('drawSpan() in 2D')
%% 4. drawLine
% As its name suggests, this function draws a line (2D or 3D) between two
% points (i.e., vectors). By default, the line type is dashed and its color is
% black but you can easily change it. Here is an example:
%%
% *Example in 2D*:
a = [2 1]'; b = [3 -2]';            % Two 2D-vectors
figure(1);clf; hold on;
drawVector([a b], {'a','b'});       % Plot the vectors
drawLine([a b]);                    % Draw a line between them
hold off;
title('Draw a line between two vectors with drawLine()')
%%
% Change the line style (see |help drawLine|).
figure(1);clf; hold on;
drawVector([a b], {'a','b'});       % Plot the vectors
drawLine([a b], 'r2-.');            % Draw a line between them
hold off;
title('Example of a different line style')
%%
% *Example in 3D*:
a = [1 2 3]'; b = [3 -1 2]';        % Two 3D-vectors
figure(1);clf; hold on;
drawVector([a b], {'a','b'});       % Plot the vectors
drawLine([a b], 'r3');              % Draw a line between them
view(15,5);
hold off;
title('Draw a line in 3D with drawLine()')
%% 5. drawXLine and drawYLine
% These commands draw a vertical/horizontal line in the xy plane at a given x/y
% value:
%
% Vertical line:
figure(1); clf;
drawVector([1 1]);
drawXLine(1,'r');
title('Draw an x-line in the xy-plane')
%%
% Horizontal line:
figure(1); clf;
drawVector([1 1]);
drawYLine(1,'r');
title('Draw an y-line in the xy-plane')
%%
% These commands work also in 3D:
figure(1); clf; drawVector([1 -1 2]/2);
for x=-1:.2:1, drawXLine(x,'2r'); for y = -1:.2:1, drawYLine(y,'2r'); end, end
title('drawXLine() and drawYLine() in 3D')
%% 6. drawCircle
% This command draws a circle or several circles in the xy-plane. 
% 
% By default, it draws a black unit circle at the origin: |drawCircle|. The
% general usage is |drawCircle(x,y,r,lineSpec)|, where x, y, and r are matrices
% of the center coordinates (|x| and |y|) and radii (|r|) of the circles;
% |lineSpec| is a string argument defining the line type.
% 
% The following examples illustrate the usage in 2D and 3D:
figure(1); clf;
subplot(2,2,1); drawCircle;
title('Draw a circle at the origin');
subplot(2,2,2); drawCircle(1,1,'rd');
title('or set another circle center');
subplot(2,2,3); drawCircle(rand(5,1), rand(5,1), rand(5,1)/3, '2r-');
title('Draw several circles at once')
subplot(2,2,4); drawPlane([0 0 1]); drawCircle(rand(5,1)*2-1, rand(5,1)*2-1, rand(5,1)/2, '2g-');
title('Use of drawCircle() in 3D')
%% 7. drawAxes
% |drawAxes()| is a function that is probably never to use directly, but which
% is called by almost all other functions in the toolbox. It plots into the
% current figure the "xy" (2D) or "xyz" (3D) coordinate axes lines going through
% the origin. It takes two mandatory parameters: a dimension number, d = {2,3},
% and a string defining the axes color.
%
% *Note:* to put the arrows at the end of coordinate lines, |drawAxes()|
% makes use of a 3d party function "arrow.m" if it is available under the MATLAB
% search path. The "arrow.m" was written by Erik Johnson and can be downloaded
% from the MATLAB Central File Exchange: 
% <http://www.mathworks.com/matlabcentral/fileexchange/278
% www.mathworks.com/matlabcentral/fileexchange/278>.
%%
% *Example in 3D:* 
load('queen.mat');                      % load the vertex and face arrays
figure(1); clf; 
drawMesh(vertex, face, 'wire');         % draw a 3D mesh
drawAxes(3, 'g');                       % Draw green axes
view(60, 10)
title('drasAxes: draw green coordinate axes through the origin');
%%
% Sometimes you would like to have different axes labels instead of the standard
% "xyz". You can specify those by calling |drawAxes| with an additional
% (optional) parameter, a cell array of strings: 
figure(1); clf; 
drawMesh(vertex, face, 'wire');
drawAxes(3, 'r', {'Axes 1','Axes 2','Axes 3'}); % Name axes
view(60, 10)
title('Different axes labeling');
%%
% *Example in 2D:*
figure(1); clf; 
plot(exp(2*pi*1i*(1:20)/20), '.'); 
drawAxes(2, 'k', {'\alpha','\beta'});
title('Draw coordinate axes in 2D')
%% 8. drawSphere
% This comman plot the unit 2D or 3D sphere under a linear transformation. By
% default, it draws the unit 3D sphere:
figure(1); clf;
drawSphere
title('Draw the unit sphere with drawSphere()')
%%
% To plot the 2D sphere, which is a circle, specify a 2-by-2 transformation
% matrix, *A*. For the unit sphere, *A* should be the identity matrix:
clf; drawSphere(eye(2),[1 1])
title('Draw the 2D unit sphere');
%%
% A linear transformation transforms the unit sphere into an ellipsoid.
% Here is an example in 2D: 
clf; drawSphere([1 1; 0 -1], 'r');
title('Draw the 2D unit sphere under a linear transformation')
%%
% Example in 3D:
clf; drawSphere(magic(3),'g',.2); view([13 5]);
title('Draw the 3D unit sphere under a linear transformation')
%%
% Note the optional parameters: 'g' and .2, which are the sphere color and
% the transparency value, respectively.
%%
% Actually, |drawSphere| allows to specify an _affine_ transformation. That is,
% linear transformation + a shift. The shift vector is given as an additional
% (optional) input parameter:
clf; drawSphere(rand(2)*2);                  % linear transform   
hold on; drawSphere(rand(2), [1 1]/2, 'g');  % affine transform
title('Linear and affine transforms of the unit sphere');
%%
clf; drawSphere(rand(3));                    % linear transformation
hold on; drawSphere(rand(3), [1 0 1], 'g');  % affine transformation
title('Linear and affine transforms of the unit sphere');
%% 9. drawMesh
% This function plots a 2D or 3D polygonal mesh. A "mesh" is defined by two arrays:
% *V* and *F*. The first one has the dimensions _n_-by-{2,3} and contains the 2D/3D
% coordinates of _n_ "vertices". The second _m_-by-k array of "faces" defines the
% connectivity of the vertices: each of the _m_ rows correspond to a face and
% contains the _indices_ (i.e., positive integers) of the vertices incident with the 
% face. Different faces can have different number of incident vertices, _k_ is the maximum 
% number of vertices among all the faces. The next examples clarify the issue:
%% 
% *Example 1: 2D mesh*
load('home.mat');                   % Load the vertex and face arrays
figure(1); clf; 
drawMesh(vertex, face, 'wire');     % Plot the mesh    
axis on; grid on; axis([-.5 1.5 0 1.5])
title('Draw a 2D mesh with drawMesh()')
%%
% *Example 2: 3D Surface plot*
load('queen.mat');                  % Load the vertex and face arrays
figure(1); clf; 
drawMesh(vertex, face)              % Plot the mesh    
view(20, 60)
title('Draw a 3D mesh with drawMesh()')
%%
% Of course, you are free to change the color of the mesh:
figure(1); clf; 
drawMesh(vertex, face, 'b')         % Plot the mesh in blue color
view(20, 60)
title('Specify the mesh color');
%%
% ... and change its transparency:
figure(1); clf; 
drawMesh(vertex, face, 'b', .5)     % Semitransparent mesh
view(20, 60)
title('Specify the mesh transparency')
%%
% *Example 3: 3D wire-frame plot*
figure(1); clf; 
drawMesh(vertex, face, 'wire')      % wire-frame plot
view(20, 60)
title('Wire-frame plot of a mesh')
%% 10. dispMEq
% This function was written to enhance the MATLAB publishing capabilities by
% the possibility to include matrix equations in a published file. In its
% simplest form, dispMEq can be used to visualize a matrix. E.g., to visualize a
% random matrix, *A*, use: 
figure(2); clf; dispMEq('A', rand(5));
%%
% By default, the numbers are shown with 2 decimals after the comma.
% However, it is possible to specify a different numeric format with an option
% 'format': 
A = rand(5); figure(2);clf; dispMEq('A', A, 'format', {'%1.1f'});
%%
% The following example shows how |dispMEq| can be used to visualize a proper
% matrix equation:
A = rand(5); [L,U] = lu(A); 
figure(3); clf; dispMEq('A = L*U', A, L, U);
%%
%  or:
A = randn(5,3); x=rand(3,1); figure(2); clf; dispMEq('A*x=b', A, x, A*x);
%%
% Beside the numeric format, dispMEq supports a kind of "symbolic" equations
% also. A symbolic representation is used automatically whenever the matrix
% elements are not numbers. Consider the following example:
A = nan(5); x = nan(5,1); b = nan(5,1); 
figure(2);clf; dispMEq('A*x=b',A,x,b);
%%
% The default format in the symbolic mode is 'elems', meaning elementwise: each
% entry of a matrix is displayed as a symbol with appropriate subscript indices.
% However, there are two additional representation format options - 'rows' and
% 'cols' - which allow to group the elements accordingly. The following example
% illustrates the three possible symbolic representation forms:
A = nan(5); figure(3);clf; dispMEq('A;A;A',A,A,A,'format',{'elems','cols','rows'});
%%
% Ultimately, |dispMEq| allows to specify a custom text displayed in each
% matrix in the equation. This can be achieved by defining the matrix as a cell
% array of strings, as in the next example:
y = {'a^1\cdot x';
     'a^2\cdot x';
     'a^3\cdot x';
     'a^4\cdot x'  };
figure(2);clf; dispMEq('A*x=y',A,x,y,'format',{'rows', 'cols','rows'})
%% 11. drawGraph
% This is a toy function that plots a toy directed graph with up to 6 nodes, n, 
% defined by its n-by-n adjacency matrix:
G = toeplitz([0 1 0 0 0 0], [0 0 0 0 0 1]) 
figure(1); clf; drawGraph(G);
%%
% <html>
% <hr>
% </html>
%
%% Comments or bugs?
% The toolbox was written by Vladimir Bondarenko for the 
% <http://sites.google.com/a/uni-konstanz.de/na09/
% "Numerical algorithms"> course to visualize the geometric ideas central to the
% methods of numerical linear algebra.
%
% For comments, bugs and suggestions contact:
% <http://sites.google.com/site/bondsite Vladimir Bondarenko>.
##### SOURCE END #####
-->
   </body>
</html>