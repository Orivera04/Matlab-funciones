{ # Template to generate different initialization files dependent
# on the external oscillator frequency.
#
# See perl Text::Template for details on how to write templates
#
# $Revision: 1.1.6.4 $
# $Date: 2004/04/19 01:24:59 $

# Generate a comment to suggest this is an automatically generated file 
}; Automatically Generated By template.pl
; Do not edit by hand.

; Copyright 2003-2004 The MathWorks, Inc.

.export usr_init

; Define some registers using relative
; addressing offset from BASE
BASE 		.equ 0x301fff;
SCCR 		.equ 0x2fc280 - BASE;
PLPRCR 	.equ 0x2fc284 - BASE;
UMCR 		.equ 0x307f80 - BASE;
DPTMCR   .equ 0x300000 - BASE;
RAMBAR   .equ 0x300004 - BASE;

; Define some SPR registers
IMMRDEF     .equ 638

.ifdef DIAB
	.section ".usr_init"
.else
    #ifdef CODE_WARRIOR
	.section .usr_init
    #else
    .error Not Supported
    #endif
.endif

usr_init:

	; Load a 1 into r5 and a 0 in r6
	; for bit set instructions
	li r5,1;				1 for bit set instructions
	li r6,0;				0 for bit clear instructions
	lis r7,BASE@h; 	base address for configuration registers
	ori r7,r7,BASE@l;
	
	; Set the IP BIT in the MSR 
	IP .equ 0x40;
   FP .equ 0x2000;
	mfmsr r3;
	ori r3,r3,(IP+FP)@l
	mtmsr r3;

	; Set the NON IEEE mode bit in the FPSCR
	NI .equ 29;
	mtfsb1 NI;

	; Set the OERC bit in the BBCMCR to 0
	; This is the default power on setting 

	; Set the ETRE bit in the BBCMCR to 1 
	BBCMCR .equ 560;
	ETRE .equ 19;
	mfspr r3,BBCMCR;
	insrwi r3,r5,1,ETRE;
	mtspr BBCMCR,r3;
	isync; Must be executed after a write to the BBCMCR 

	RTDIV .equ 7;
   DFNL .equ 25;
   DFNH .equ 29;
   
   ; Set the PIT clock divider to 256 as default
	; Set the RTDIV bit in the SCCR
   ; clear DFNH and DFNL
	lwz   	r4,SCCR(r7);
	insrwi	r4,r5,1,RTDIV;
   insrwi   r4,r6,3,DFNH;
   insrwi   r4,r6,3,DFNL;
	stw   	r4,SCCR(r7);

	HSPEED .equ 3;
	; Run the UIMB at full speed by clearing the HSPEED bit
	; in the UMCR
	lwz 		r4,UMCR(r7);
	insrwi	r4,r6,1,HSPEED;
	stw 		r4,UMCR(r7);

	;----------------------------------------------------
	; Configure External Memory
	;----------------------------------------------------

	; Base address of memory controller
	BRBASE .equ 0x2FC000
	; Memory controller base register offsets
	BR0DEF    .equ 0x0100
	BR1DEF    .equ 0x0108
	BR2DEF    .equ 0x0110
	BR3DEF    .equ 0x0118
	; Memory controller register address offsets
	OR0    .equ 0x0104
	OR1    .equ 0x010C
	OR2    .equ 0x0114
	OR3    .equ 0x011C


	; Disable chip selects  2 & 3
	lis r3,BRBASE@h;
	ori r3,r3,BRBASE@l;
	li  r4,0;

   stw r4,BR2DEF(r3);
	stw r4,BR3DEF(r3);
	
   ; FLEN is bit 11
   FLEN  .equ 0x800;
  
   ; check to see if internal flash is being used
   ; and setup Chip Select 0 (External flash) accordingly
   ; FLEN = 0 : On chip flash is disabled
   ; FLEN = 1 : On chip flash is enabled

   mfspr r8,IMMRDEF;
   andi. r8,r8,FLEN;
   cmpwi r8,0;
   bne flenset;
   ; FLEN is clear --> boot from external flash
   ; Enable Chip Select 0 (Map the correct amount of memory)
   BR0_WORD .equ 0x{sprintf('%x',eval($flash_org))} | 0x1 ;  Locate at external flash location and enable
	OR0_WORD .equ 0x{$x = eval($flash_len);sprintf('%x',~($x-1)&0xffff0000)} ;  Set the address space size

	lis r4,BR0_WORD@h;
	ori r4,r4,BR0_WORD@l
	stw r4,BR0DEF(r3);

   lis r4,OR0_WORD@h;
   ori r4,r4,OR0_WORD@l;
   stw r4,OR0(r3);
   
   b flenexit;
flenset:
   ; Disable Chip Select 0
   stw r4,BR0DEF(r3);
flenexit:

	; Configure External Ram on Chip Select 1
	BR1_WORD .equ 0x{sprintf('%x',eval($e_ram_org))} | 0x1 ;  Locate at 0x400000 and enable
	OR1_WORD .equ 0x{$x = eval($e_ram_len);sprintf('%x',~($x-1)&0xffff0000)} ;  Set the address space size
	lis r4,BR1_WORD@h;
	ori r4,r4,BR1_WORD@l
	stw r4,BR1DEF(r3);

   lis r4,OR1_WORD@h;
   ori r4,r4,OR1_WORD@l;
   stw r4,OR1(r3);

	; Ensure that checkstop exceptions will generate a reset by setting
	; the CSR bit in the PLPRCR
	; PLPRCR .equ 0x2FC284
	; Note that MF must retain its reset value that is dependent on
	; the external oscillator frequency
	CSR .equ 24;
	SPLS .equ 15;
	TEXPS .equ 17; 
   MF .equ 0; 
   DIVF .equ 27;
   
   li r3, {$POWER_ON_MF_VALUE}; 
   
	lwz r4,PLPRCR(r7);
	insrwi	r4,r6,1,SPLS
	insrwi	r4,r6,1,TEXPS
	insrwi	r4,r5,1,CSR;
   insrwi   r4,r3,12,MF; 
   insrwi   r4,r6,5,DIVF;
	stw 		r4,PLPRCR(r7);

   ; wait for PLL to lock
loop:
   lwz r4,PLPRCR(r7);
   ; extract and right justify immediate
   extrwi r3,r4,1,SPLS;
   cmpwi r3,0;
   beq loop;

	; Ensure that the TPU RAM is enabled so that we can
	; use it for the ccpBootData
	li       r4,0;
	sth      r4,DPTMCR(r7);
	li       r4,0xFFA0;
	sth      r4,RAMBAR(r7);

	blr;
