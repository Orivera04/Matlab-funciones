function [score, alignment, outptr] = hmmprofalign(model,seq,varargin)
%HMMPROFALIGN performs sequence profile alignment using a Hidden Markov Model.
%
%   HMMPROFALIGN(MODEL,SEQ) returns the score for the optimal alignment of
%   the query amino acid (or nucleotide) sequence SEQ to the profile Hidden
%   Markov Model MODEL. Scores are computed using log-odd ratios for 
%   emission probabilities and log probabilities for state transitions.
%
%   [SCORE, ALIGNMENT] = HMMPROFALIGN(MODEL,SEQ) returns a string showing
%   the optimal profile alignment. Capital letters and dashes correspond to
%   MATCH and DELETE states respectively (the combined count is equal to
%   the number of states in the model). Lowercase letters are emitted by
%   the INSERT states. For more information about the HMM profile, see
%   HMMPROFSTRUCT. 
%
%   [SCORE, ALIGNMENT, POINTERS] = HMMPROFALIGN(MODEL,SEQ) returns a vector
%   of the same length as the profile model with indices pointing to the
%   respective symbols of the query sequence. Null pointers (NaN) mean that
%   such states did not emite a symbol in the aligned sequence, either
%   because they represent model jumps from the BEGIN state to a MATCH
%   state or from a MATCH state to the END state, or because the alignment
%   passed through DELETE states.
%
%   HMMPROFALIGN(...,'SHOWSCORE',true) displays the scoring space and the
%   winning path. Default is false.
%
%   HMMPROFALIGN(...,'FLANKS',true) includes the symbols generated by the
%   FLANKING INSERT states in the ALIGNMENT output. Default is false.
%
%   HMMPROFALIGN(...,'SCOREFLANKS',true) includes the transition
%   probabilities for the flanking states in the raw score. Default is
%   false.
%
%   HMMPROFALIGN(...,'SCORENULLTRANSITIONS',true) adjusts the raw score
%   using the null model for transitions (MODEL.NullX). Default is false.
%
%   Note: Multiple hit alignment is not supported in this implementation.
%   All the MODEL.LoopX probabilities are ignored.
%    
%   Example:
%
%     load('hmm_model_examples','model_7tm_2') % load a model example
%     load('hmm_model_examples','sequences')   % load a sequence example
%     SCCR_RABIT=sequences(2).Sequence;
%     [s,a]=hmmprofalign(model_7tm_2,SCCR_RABIT,'showscore',true)
%
%   See also GETHMMPROF, HMMPROFESTIMATE, HMMPROFGENERATE, HMMPROFMERGE,
%   HMMPROFSTRUCT, PFAMHMMREAD, SHOWHMMPROF.

%   References:
%   R. Durbin, S. Eddy, A. Krogh, and G. Mitchison. Biological Sequence
%   Analysis. Cambridge UP, 1998.

%   Copyright 2003-2004 The MathWorks, Inc.
%   $Revision: 1.15.6.7 $  $Date: 2004/04/01 15:57:59 $

% Validate HMM model:
try   
    model = checkhmmprof(model);
catch 
    rethrow(lasterror);
end

% Validate query sequence:
if isstruct(seq)
    seq = fieldfromstruct(seq,'Sequence');
    if isempty(seq) || (iscell(seq)&&all(cellfun('isempty',seq)))
        error('Bioinfo:SequenceNotFoundInStructure',...
            'Sequence data was not found in the input structure.');
    end
end

if iscell(seq) 
    if numel(seq)>1
            warning('Bioinfo:NoMultipleSequences', ...
            ['Multiple sequences were found in the second input.\n',...
            'HMMPROFALIGN will only work with the first sequence.'])
    end
    seq = seq{1};
end

if ~ischar(seq) || ~isvector(seq)
    error('Bioinfo:IncorrectInputSequence','Input sequence must be a char vector')
end

% sequence may be prealigned, remove any space character
seq = regexprep(seq,'[-~\s\.]','');

% default options for some varargin pairs
showscore = false;
includeflanks = false;
scorenulltransitions = false;
scoreflanks = false;
includePEC = false;

if nargin > 2
    if rem(nargin,2) == 1
        error('Bioinfo:IncorrectNumberOfArguments','Incorrect number of arguments to %s.',mfilename);
    end
    okargs = {'showscore','flanks','scorenulltransitions','scoreflanks','includePEC'};
    for j=1:2:nargin-2
        pname = varargin{j};
        pval = varargin{j+1};
        k = strmatch(lower(pname), okargs);
        if isempty(k)
            error('Bioinfo:UnknownParameterName','Unknown parameter name: %s.',pname);
        elseif length(k)>1
            error('Bioinfo:AmbiguousParameterName','Ambiguous parameter name: %s.',pname);
        else
            logpval = opttf(pval);
            if isempty(logpval)
                 error('Bioinfo:InputOptionNotLogical',...
                       '%s must be a logical value, true or false.',...
                       upper(okargs{k}));
            end
            switch(k)
                case 1,  showscore = logpval; 
                case 2,  includeflanks = logpval;
                case 3,  scorenulltransitions = logpval;
                case 4,  scoreflanks = logpval;
                case 5,  includePEC = logpval;
            end
        end
    end
end

seqLength=length(seq);

profLength=model.ModelLength;
switch upper(model.Alphabet)
    case 'AA', intseq=aa2int(seq);
               alphaLength = 20;
    case 'NT', intseq=nt2int(seq);
               alphaLength = 4;
end

if any(intseq > alphaLength) | any(~intseq)
   error('Bioinfo:SymbolsNotDefined',...
         'The input sequence has symbols not defined in the alphabet of the model. \nUse SHOWHMMPROF to see which are the supported symbols by your HMM profile.');
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% reading in model structure

[lastwmsg,lastwid]=lastwarn;
warnState=warning('off');

% NULL MODEL EMISSION LOG-PROB (nelp)
nep = model.NullEmission;
nelp = log2(nep);

% MATCH EMISSION LOG-PROB (melp)
mep = model.MatchEmission;
melp = log2(mep);
% MATCH EMISSION LOG-ODDS RATIO (melor)
melor = melp-repmat(nelp,profLength,1);

% INSERT EMISSION LOG-PROB (ielp)
iep = model.InsertEmission;
ielp = log2(iep);
% INSERT EMISSION LOG-ODDS RATIO (ielor)
ielor = ielp-repmat(nelp,profLength,1);

% MATCH TRANSITION LOG-PROB (mxlp)
mxp = [model.MatchX; 0 0 0 1];
mxlp = log2(mxp);

% INSERT TRANSITION LOG-PROB (ixlp)
ixp=[model.InsertX; 0 0];
ixlp = log2(ixp);

% DELETE TRANSITION LOG-PROB (dxlp)
dxp = [model.DeleteX; 0 0];
dxlp = log2(dxp);

% BEGIN-[DEL_1-MATCH_X] TRANSITION LOG-PROB (bxlp)
% [xBD1, xBM1, xBM2, xBM3, xBM4 ... ]
bxp = model.BeginX;
bxlp = log2(bxp);

% LEFT-INSERT TRANSITIONS LOG-PROB VECTOR (lixlpv)
% [xNB, xNN xNB, xNN xNN xNB, xNN xNN xNN xNB ...]
lixp = model.FlankingInsertX(:,1);
lixlp = log2(lixp);
lixlpv = cumsum([lixlp(1),repmat(lixlp(2),1,seqLength-1)]);

% RIGTH-INSERT TRANSITIONS LOG-PROB VECTOR (rixlpv)
% [... xCC xCC xCC xCT, xCC xCC xCT, xCC xCT, xCT]
rixp = model.FlankingInsertX(:,2);
rixlp = log2(rixp);
rixlpv = fliplr(cumsum([rixlp(1),repmat(rixlp(2),1,seqLength-1)]));

% LOOP INSERT TRANSITION PROB VECTOR (loxlp)
% [xEC xJB ; xEJ xJJ]
loxp = model.LoopX;
loxlp = log2(loxp);

% NULL TRANSITION PROB (nxp)
nxp = model.NullX;
nxlp = log2(nxp);

warning(warnState);
lastwarn(lastwmsg,lastwid);

% reading in model structure (end)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Set up storage for dynamic programming matrix:
% for keeping the maximum scores for every state

VM =  zeros(profLength,seqLength);
VI =  zeros(profLength,seqLength);
VD =  zeros(profLength,seqLength);

% and for the back tracing pointers
ptrM(profLength,seqLength) = uint8(0);
ptrI(profLength,seqLength) = uint8(0);
ptrD(profLength,seqLength) = uint8(0);

% Initializing dynamic programming matrixes

  % two possible ways to get to a match state in the first column
  %           1) jumping from B or 2) trough delete states
VM(2:end,1) = max(bxlp(3:end),cumsum(dxlp(1:end-1,2))+bxlp(1));
VM(:,1) = VM(:,1) + melor(:,intseq(1));
if scoreflanks 
    VM(:,1) = VM(:,1) + lixlpv(1); 
end
VM(1,:) = bxlp(2) + melor(1,intseq);
if scoreflanks
    VM(1,:) = VM(1,:) + lixlpv;
end
VI(1,:) = -inf;
VI(:,1) = -inf;
VD(1,:) = -inf;
VD(:,1) = -inf;

% main loop runs through the matrix looking for maximal scores
for si = 2:seqLength             % sequence index
    for pi = 2:profLength        % profile index

        %%% Operate 'match' state
        inM = VM(pi-1,si-1) + mxlp(pi-1,1);
        inI = VI(pi-1,si-1) + ixlp(pi-1,1);
        inD = VD(pi-1,si-1) + dxlp(pi-1,1);
        inB = lixlpv(si) + bxlp(pi+1);
        if inM > inI
            if inM > inD
                VM(pi,si) = inM; ptrM(pi,si) = 1; % 001 diagonal
            elseif inD > inM
                VM(pi,si) = inD; ptrM(pi,si) = 2; % 010 up
            else % inM == inI
                VM(pi,si) = inM; ptrM(pi,si) = 3; % 001 diag & up
            end
        elseif inI > inM
            if inI > inD
                VM(pi,si) = inI; ptrM(pi,si) = 4; % 100 left
            elseif inD > inI
                VM(pi,si) = inD; ptrM(pi,si) = 2; % 010 up
            else % inI == inD
                VM(pi,si) = inI; ptrM(pi,si) = 6; % 110 up & left
            end
        else % inI == inM
            if inM > inD
                VM(pi,si) = inM; ptrM(pi,si) = 5; % 101 diag & left
            elseif inD > inM
                VM(pi,si) = inD; ptrM(pi,si) = 2; % 010 up
            else % inM == inI == inD
                VM(pi,si) = inM; ptrM(pi,si) = 7; % 111 all
            end
        end
        if inB > VM(pi,si)
            VM(pi,si) = inB; ptrM(pi,si) = 0; %000 begin st
        end

        VM(pi,si) = VM(pi,si) + melor(pi,intseq(si)); %include emission

        %%% Operate 'insert' state
        inM = VM(pi,si-1) + mxlp(pi,2);
        inI = VI(pi,si-1) + ixlp(pi,2);
        if inM > inI
            VI(pi,si) = inM; ptrI(pi,si) = 1;
        elseif inM < inI
            VI(pi,si) = inI; ptrI(pi,si) = 4;
        else % inM == inI
            VI(pi,si) = inM; ptrI(pi,si) = 5;
        end

        VI(pi,si) = VI(pi,si) + ielor(pi,intseq(si)); %include emission

        %%% Operate 'delete' state
        inM = VM(pi-1,si) + mxlp(pi-1,3);
        inD = VD(pi-1,si) + dxlp(pi-1,2);
        if inM > inD
            VD(pi,si) = inM; ptrD(pi,si) = 1;
        elseif inM < inD
            VD(pi,si) = inD; ptrD(pi,si) = 2;
        else % inM == inD
            VD(pi,si) = inM; ptrD(pi,si) = 3;
        end

    end % for pi = 2:profLength+1
end % for si = 2:seqLength+1

if showscore %for display, VM is obscured if Px(match-end)=0
    VMM = VM;
end

%%% Operate 'End' State
for si = 1:seqLength
    VM(:,si) = VM(:,si)+mxlp(:,4);
end

%%% score the right flanking states
if scoreflanks
    for pi = 1:profLength
        VM(pi,:) = VM(pi,:)+rixlpv;
    end
    VD(end,:) = VD(end,:)+rixlpv;
end

% finding maximum score
[score,loc] = max(VM(:));
[pi,si] = ind2sub(size(VM),loc);
state=1;
% checking if finished through the last delete state
if max(VD(end,:))>score;
    [score,si] = max(VD(end,:));
    state = 2;
    pi = profLength;
    while bitget(state,2) % more delete states ?
        state = ptrD(pi,si);
        pi = pi-1;
    end
end

% trace back
path = zeros(seqLength+profLength,2);
step = seqLength+profLength; %start at the end
while state;
    path(step,:)=[pi,si];
    switch state
        case 1, %diagonal
            state = ptrM(pi,si);
            pi = pi-1; si = si-1;
        case 2, %delete
            state = ptrD(pi,si);
            pi = pi-1;
        case 4, %insert
            state = ptrI(pi,si);
            si = si-1;
        case 6, %delete or insert, prefer delete
            state = ptrD(pi,si);
            pi = pi-1;
        otherwise %all others as diagonal
            pi = pi-1; si = si-1;
            state = ptrM(pi,si);
    end
    step=step-1;
end
path(1:step,:)=[];

% pointer to create the output str alignment
outptr = zeros(profLength,1);
outptr(path(:,1))=path(:,2);
outptr(find(~diff([0;outptr]))) = 0;

% create output string
alignment = char(zeros(1,size(path,1)));
pi = 0; ai = 0;
last_si = min(outptr(outptr>0))-1;
lfi = last_si;
while pi<profLength
    ai = ai+1;
    pi = pi+1;
    si = outptr(pi);
    if si %match & inserts
        alignment(ai) = upper(seq(last_si+1));
        for ind = last_si+2:si
            ai=ai+1;
            alignment(ai) = lower(seq(ind));
        end
        last_si = si;
    else %si==0 -> delete
        alignment(ai) = '-';
    end
end
rfi = last_si+1;

outptr(outptr==0) = NaN;

% Correct alignment to include flank insert symbols if necessary
if includeflanks
    alignment = [lower(seq(1:lfi)) alignment lower(seq(rfi:end))];
end

% Correct raw score to include null transition probabilities
if scorenulltransitions
    if scoreflanks
        score = score - nxlp(2)*(seqLength-1)  - nxlp(1);
    else
        score = score - nxlp(2)*(rfi-lfi-2) - nxlp(1);
    end
end

% Modify raw score to include P[E->C] to match the score provided by hmmer 2.2g
if includePEC
     score = score + loxlp(1);
end

if showscore
    figure
    VMM = max(VMM,max(VD,VI));
    clim=max(max(abs(VMM(~isinf(VMM)))));
    imagesc(VMM,[-clim clim]);
    colormap(privateColorMap(1));
    colorbar
    title('log-odds score for best path')
    xlabel('Sequence index')
    ylabel('Profile state')
    hold on
    plot(path(:,2),path(:,1),'k.')
end

function pcmap = privateColorMap(selection)
%PRIVATECOLORMAP returns a custom color map
switch selection
    case 1, pts = [0 0 .3 20;
            0 .1 .8 25;
            0 .9 .5 15;
            .9 1 .9 8;
            1 1 0 26;
            1 0 0 26;
            .4 0 0 0];
    otherwise, pts = [0 0 0 128; 1 1 1 0];
end
xcl=1;
for i=1:size(pts,1)-1
    xcl=[xcl,i+1/pts(i,4):1/pts(i,4):i+1];
end
pcmap = interp1(pts(:,1:3),xcl);
