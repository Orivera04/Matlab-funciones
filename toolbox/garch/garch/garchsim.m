function [e, h, y] = garchsim(spec, nSamples, nPaths, seed, X, tolerance, e0, s0, y0)
%GARCHSIM Univariate GARCH process simulation.
%   Given specifications for the conditional mean and variance of a univariate 
%   time series, simulate sample paths for the return series, innovations, and 
%   conditional standard deviation processes. Each of NUMPATHS sample paths are 
%   sampled at NUMSAMPLES observations. The conditional mean may be of general 
%   ARMAX form and conditional variance of general GARCH, EGARCH, or GJR form.
%
%   [Innovations, Sigmas, Series] = garchsim(Spec)
%   [Innovations, Sigmas, Series] = garchsim(Spec, NumSamples, NumPaths, State, 
%     X, Tolerance, PreInnovations, PreSigmas, PreSeries)
%
%   Optional Inputs: NumSamples, NumPaths, State, X, Tolerance, PreInnovations, 
%     PreSigmas, PreSeries
%
% Inputs:
%   Spec - Structure specification for the conditional mean and variance 
%     models. Spec is a GARCH Toolbox specification structure generated by
%     calling the function GARCHSET or GARCHFIT.
%
% Optional Inputs:
%   NumSamples - Positive integer indicating the number of observations (sample
%     size) generated for each path of the Innovations, Sigmas, and Series 
%     time series outputs (see below). If empty or missing, the default is 100.
%
%   NumPaths - Positive integer indicating the number of sample paths 
%     (realizations) generated for the Innovations, Sigmas, and Series time 
%     series outputs. If empty or missing, the default is 1.
%
%   State - Scalar random number generator state. If empty or missing, default 
%     is 0 (the MATLAB initial state).
%
%   X - Time series regression matrix of explanatory variable(s). Typically, X 
%     is a regression matrix of asset returns (e.g., the return series of an 
%     equity index). Each column of X is an individual time series used as an 
%     explanatory variable in the regression component of the conditional mean. 
%     In each column of X, the first row contains the oldest observation and 
%     the last row the most recent. If empty or missing, the conditional mean 
%     will have no regression component. If specified, then at least the most 
%     recent NUMSAMPLES observations of each return series must be valid (i.e.,
%     non-NaN). When the number of valid observations in each series exceeds 
%     NUMSAMPLES, only the most recent NUMSAMPLES observations of X are used.
%
%   Tolerance - Scalar transient response tolerance (0 < Tolerance <= 1). When 
%     the composite conditional mean and variance model is viewed from a 
%     linear filtering perspective, estimate the number of observations needed
%     for the magnitude of the impulse response (which begins at 1) to decay 
%     below this Tolerance value (subject to a 10,000 observation maximum, see 
%     below). The impulse response estimates are based on the magnitude of the 
%     largest eigenvalue of the auto-regressive polynomial. This tolerance 
%     parameter is ignored if pre-sample conditioning information has been 
%     specified (see PreInnovations, PreSigmas, and PreSeries below). If empty 
%     or missing, the default is 0.01 (i.e., 1%).
%
%   PreInnovations - Time series matrix or column vector of pre-sample 
%     innovations upon which the recursive mean and variance models are 
%     conditioned. This array may have any number of rows, provided sufficient 
%     observations exist to initialize the mean and variance equations. 
%     Thus, if M and Q are the number of lagged innovations required by the 
%     conditional mean and variance equations, respectively, then the
%     PreInnovations array must have at least max(M,Q) rows. If the number of
%     rows exceeds max(M,Q), then only the last (i.e., most recent) max(M,Q)
%     rows are used as pre-sample observations. If PreInnovations is a matrix, 
%     then it must have NUMPATHS columns. 
%
%   PreSigmas - Time series matrix or column vector of positive pre-sample 
%     conditional standard deviations upon which the recursive variance model 
%     is conditioned. This array may have any number of rows, provided 
%     sufficient observations exist to initialize the conditional variance 
%     equation. Thus, if P and Q are the number of lagged conditional standard 
%     deviations and lagged innovations required by the conditional variance 
%     equation, respectively, then the PreSigmas array must have at least P 
%     rows for GARCH and GJR models, and at least max(P,Q) rows for EGARCH 
%     models. If the number of rows exceeds the requirement, then only the 
%     last (i.e., most recent) rows are used as pre-sample observations. If 
%     PreSigmas is a matrix, then it must have NUMPATHS columns.
%
%   PreSeries - Time series matrix or column vector of pre-sample observations
%     of the return series of interest upon which the recursive mean model 
%     is conditioned. This array may have any number of rows, provided 
%     sufficient observations exist to initialize the conditional mean equation.
%     Thus, if R is the number of lagged observations of the return series 
%     required by the conditional mean equation, then the PreSeries array must
%     have at least R rows. If the number of rows exceeds R, then only the 
%     last (i.e., most recent) R rows are used as pre-sample observations. If 
%     PreSeries is a matrix, then it must have NUMPATHS columns.
%
% Outputs:
%   Innovations - NUMSAMPLES by NUMPATHS time series matrix of innovations, 
%     representing a mean zero, discrete-time stochastic process. The 
%     Innovations time series follows the input conditional variance model 
%     specification. Rows are sequential time observations, columns are 
%     sample paths (realizations).
%
%   Sigmas - NUMSAMPLES by NUMPATHS time series matrix of conditional standard
%     deviations of the corresponding Innovations matrix. Innovations and 
%     Sigmas are the same size, and form a matching pair of matrices. Rows are
%     sequential times observations, columns are sample paths (realizations).
%
%   Series - NUMSAMPLES by NUMPATHS time series matrix of the return series 
%     of interest. Series is the dependent stochastic process and follows the
%     input conditional mean specification of general ARMAX form. Rows are 
%     sequential times observations, columns are sample paths (realizations).
%
% Notes:
% (1) The Tolerance parameter is designed to provide users with a mechanism
%     by which to manage the conflict between transient minimization and 
%     memory usage. Smaller Tolerance values generate output processes that 
%     more closely approximate true steady-state behavior, but require more
%     memory to accommodate the additional filtering required. Conversely, 
%     larger Tolerance values require less memory, but produce outputs in 
%     which transients tend to persist. Notice that Tolerance is completely 
%     ignored when actual pre-sample observations are specified. Thus, in the 
%     absence of user-specified pre-sample information, Tolerance determines 
%     the number observations allocated to the pre-sample transient decay 
%     period, but is subject to a maximum of 10,000 observations to prevent 
%     out-of-memory conditions. In other words, the number of observation 
%     periods required for the magnitude of any transients to decay is 
%     calculated from Tolerance, but is not allowed to exceed 10,000.
% (2) PreInnovations, PreSigmas, and PreSeries are the user-specified 
%     pre-sample observations associated with the outputs Innovations, Sigmas,
%     and Series, respectively. When specified, these pre-sample arrays are 
%     used to initiate the filtering process, and thus form the conditioning 
%     set upon which the simulated realizations are based. When no explicit 
%     pre-sample data is provided, the necessary pre-sample observations are 
%     derived by conventional time series techniques as outlined in the GARCH 
%     Toolbox User's Guide.
% (3) When PreInnovations, PreSigmas, and PreSeries inputs are specified as 
%     matrices, they MUST have NUMPATHS columns, in which case the pre-sample 
%     information of a given column is used to initiate the simulation of the 
%     corresponding column of the Innovations, Sigmas, and Series outputs. 
% (4) When PreInnovations, PreSigmas, and PreSeries inputs are specified as 
%     column vectors, the vector is applied to each and every column of the 
%     corresponding Innovations, Sigmas, and Series time series outputs. In 
%     this situation, all simulated sample paths share a common conditioning
%     set. This allows the simulated sample paths to evolve from a common 
%     starting point, and allows Monte Carlo simulation of forecasts and 
%     forecast error distributions. When pre-sample vectors are not specified,
%     sample paths share no common conditioning set, resulting in entirely 
%     independent realizations.
% (5) PreInnovations and PreSigmas are usually companion inputs. Although 
%     both are optional, when specified, they are typically entered together. 
%     A notable exception would be a GARCH(0,Q) (i.e., an ARCH(Q)) model in 
%     which the conditional variance equation does not require lagged 
%     conditional variance forecasts.
% (6) Similarly, PreSeries is only necessary when simulation of the output
%     return Series is desired and when the conditional mean equation has 
%     an auto-regressive component.
% (7) If the conditional mean and/or conditional variance equation is not 
%     recursive in any way, then certain pre-sample information is unnecessary
%     to jump-start the model(s). However, specifying redundant pre-sample 
%     information is NOT an error, and any pre-sample observations specified 
%     for models that require no such information are simply ignored.
%
% See also GARCHSET, GARCHGET, GARCHPRED, GARCHFIT.

%   Copyright 1999-2003 The MathWorks, Inc.   
%   $Revision: 1.10.4.1 $   $Date: 2003/05/08 21:45:31 $

%
% References:
%
%   Bollerslev, T. (1986), "Generalized Autoregressive Conditional 
%     Heteroskedasticity", Journal of Econometrics, vol. 31, pp. 307-327.
%
%   Bollerslev, T. (1987), "A Conditionally Heteroskedastic Time Series Model
%     for Speculative Prices and Rates of Return", The Review Economics and
%     Statistics, vol. 69, pp 542-547.
%
%   Box, G.E.P., Jenkins, G.M., Reinsel, G.C., "Time Series Analysis: 
%     Forecasting and Control", 3rd edition, Prentice Hall, 1994.
%
%   Enders, W., "Applied Econometric Time Series", John Wiley & Sons, 1995.
%
%   Engle, R.F. (1982), "Autoregressive Conditional Heteroskedasticity 
%     with Estimates of the Variance of United Kingdom Inflation", 
%     Econometrica, vol. 50, pp. 987-1007.
%
%   Engle, R.F., Lilien, D.M., Robins, R.P. (1987), "Estimating Time Varying 
%     Risk Premia in the Term Structure: The ARCH-M Model", Econometrica, 
%     vol. 59, pp. 391-407.
%
%   Glosten, L.R., Jagannathan, R., Runkle, D.E. (1993), "On the Relation between 
%     Expected Value and the Volatility of the Nominal Excess Return on Stocks", 
%     The Journal of Finance, vol.48, pp. 1779-1801.
%
%   Hamilton, J.D., "Time Series Analysis", Princeton University Press, 1994.
%
%   Nelson, D.B., "Conditional Heteroskedasticity in Asset Returns: A New 
%     Approach", Econometrica, vol. 59, pp. 347-370.
%

%
% Check input parameters and set defaults.
%

if (nargin >= 2) & ~isempty(nSamples)
   if prod(size(nSamples)) > 1
      error('GARCH:garchsim:NonScalarNumSamples' , ' Number of observations ''NumSamples'' must be a scalar.');
   end
   if (round(nSamples) ~= nSamples) | (nSamples <= 0)
      error('GARCH:garchsim:NonIntegerNumSamples' , ' Number of observations ''NumSamples'' must be a positive integer.');
   end
else
   nSamples  =  100;   % Set default.
end

if (nargin >= 3) & ~isempty(nPaths)
   if prod(size(nPaths)) > 1
      error('GARCH:garchsim:NonScalarNumPaths' , ' Number of sample paths ''NumPaths'' must be a scalar.');
   end
   if (round(nPaths) ~= nPaths) | (nPaths <= 0)
      error('GARCH:garchsim:NonIntegerNumPaths' , ' Number of sample paths ''NumPaths'' must be a positive integer.');
   end
else
   nPaths  =  1;       % Set default.
end

if (nargin >= 4) & ~isempty(seed)
   if prod(size(seed)) > 1
      error('GARCH:garchsim:NonScalarState' , ' Random number generator ''State'' must be a scalar.');
   end
else
   seed  =  0;         % Set default.
end

%
% Scrub the regression matrix and ensure sufficient observations exist. 
% Note that, in contrast to estimation, simulation of the innovations 
% process is independent of X. However, during estimation, the innovations
% process must be inferred from the conditional mean specification, which
% may include a regression component if desired.
%

if (nargin >= 5) & ~isempty(X) & (nargout >= 3)

   if prod(size(X)) == length(X)      % Check for a vector.
      X  =  X(:);                     % Convert to a column vector.
   end
%
%  Retain the last contiguous block of non-NaN (i.e, non-missing-valued) observations only. 
%
   if any(isnan(X(:)))
      X  =  X((max(find(isnan(sum(X,2)))) + 1):end , :);
   end

   if size(X,1) < nSamples
      error('GARCH:garchsim:NotEnoughData' , ' Regression matrix ''X'' has insufficient number of observations.');
   end
%
%  Ensure number of regression coefficients match number of regressors.
%
   regress =  garchget(spec , 'Regress');    % Conditional mean regression coefficients.

   if size(X,2) ~= length(regress)
      error('GARCH:garchsim:InputMismatch' , ' Number of ''Regress'' coefficients unequal to number of regressors in ''X''.');
   end

else

   X        =  [];   % Ensure X exists.
   regress  =  [];

end

%
% Provide error-checking for the transient response tolerance parameter. Notice
% that the tolerance parameter is ignored if pre-sample conditioning information
% has been specified.
%

if (nargin == 6) & ~isempty(tolerance)
   if (prod(size(tolerance)) > 1) | (tolerance <= 0) | (tolerance > 1) 
      error('GARCH:garchsim:InvalidTolerance' , ' ''Tolerance'' must be a positive scalar less than or equal to 1.');
   end
else
   tolerance  =  0.01;         % Set default.
end

%
% Ensure necessary coefficients exist and have proper dimensions.
%
% Notes:
%  (1) The constant 'C' is required only when simulating the conditional mean.
%
%  (2) The 'AR' and 'MA' coefficients, and associated orders 'R' and 'M', may
%      be used to determine the number of observations needed for transients
%      to decay. Regardless of whether the conditional mean is simulated, we 
%      require the 'AR' and 'MA' coefficients. This allows users to replicate
%      innovations and conditional variances from simulations with and without
%      computing the conditional mean.
%

R      =  garchget(spec , 'R');       % Conditional mean AR order.
M      =  garchget(spec , 'M');       % Conditional mean MA order.
P      =  garchget(spec , 'P');       % Conditional variance order for lagged variances.
Q      =  garchget(spec , 'Q');       % Conditional variance order for lagged residuals.

C      =  garchget(spec , 'C');       % Conditional mean constant.
AR     =  garchget(spec , 'AR');      % Conditional mean AR coefficients.
MA     =  garchget(spec , 'MA');      % Conditional mean MA coefficients.

K      =  garchget(spec , 'K');       % Conditional variance constant.
GARCH  =  garchget(spec , 'GARCH');   % Conditional variance coefficients for lagged variances.
ARCH   =  garchget(spec , 'ARCH');    % Conditional variance coefficients for lagged residuals.

if isempty(C) & (nargout >= 3)
   error('GARCH:garchsim:UnspecifiedC' , ' Conditional mean constant ''C'' must be specified.');
end
if isempty(AR) & (R ~= 0)
   error('GARCH:garchsim:UnspecifiedAR' , ' Auto-regressive ''AR'' coefficients must be specified.');
end
if isempty(MA) & (M ~= 0)
   error('GARCH:garchsim:UnspecifiedMA' , ' Moving-average ''MA'' coefficients must be specified.');
end
if isempty(K)
   error('GARCH:garchsim:UnspecifiedK' , ' Conditional variance constant ''K'' must be specified.');
end
if isempty(GARCH) & (P ~= 0)
   error('GARCH:garchsim:UnspecifiedGARCH' , ' ''GARCH'' coefficients of lagged variances must be specified.');
end
if isempty(ARCH)  & (Q ~= 0)
   error('GARCH:garchsim:UnspecifiedARCH' , ' ''ARCH'' coefficients of lagged residuals must be specified.');
end

%
% SPECIAL NOTE: Simulation of Variance-in-Mean Models
%
% In addition to the fields formally documented, the GARCH Toolbox specification 
% structure supports the following UNDOCUMENTED parameters:
%
%       InMean - Scalar coefficient for variance-in-mean models. 
%                [ scalar coefficient | {[]} ]
%    FixInMean - Equality constraint indicator for InMean coefficient.
%                [ logical scalar | {[]} ]
%
% In the code that follows, the 'InMean' parameter is a coupling coefficient
% that allows inclusion of the conditional variance as an explanatory variable
% in the conditional mean equation. The 'InMean' parameter field is applicable 
% to all supported volatility models (i.e., GARCH-M, EGARCH-M, and GJR-M models).
%
% However, when simulating GARCH-M, EGARCH-M, or GJR-M variance-in-mean models,
% it is the conditional VARIANCE that is included in the mean equation.
%
% Again, please note that simulation of GARCH-M, EGARCH-M, or GJR-M models is
% an UNDOCUMENTED feature!
%

%
% Ensure the variance model specification is complete.
%
% Notes: 
%  (1) The presence of an appended dash (i.e., '-') in the 'VarianceModel'
%      field is an indication that the conditional variance, regardless 
%      of which volatility model is used, is included in the conditional 
%      mean equation.
%
%  (2) The 'InMean' coefficient is required only when simulating the 
%      conditional mean.
%

varianceModel  =  garchget(spec , 'VarianceModel');

[varianceModel , InMeanString] = strtok(varianceModel , '-');

isVarianceInMean = ~isempty(InMeanString);
InMean           =  garchget(spec , 'InMean');

if isVarianceInMean & isempty(InMean) & (nargout >= 3)
   error('GARCH:garchsim:UnspecifiedInMean' , ' Variance-in-mean coefficient ''InMean'' must be specified.');
end

%
% Ensure that Leverage coefficients are specified for 
% the asymmetric EGARCH and GJR models.
%

Leverage  =  garchget(spec , 'Leverage');

if strcmp(varianceModel , 'EGARCH') | strcmp(varianceModel , 'GJR')

   if isempty(Leverage)  & (Q ~= 0)
      error('GARCH:garchsim:UnspecifiedLeverage' , ' ''Leverage'' coefficients must be specified for ''EGARCH'' and ''GJR'' models.');
   end

end

%
% Simulation processing requires pre-sample values for conditioning. 
% This pre-sample information may be specified by the user, or generated 
% automatically.
% 
% Let y(t) = return series of interest (assumed stationary)
%     e(t) = innovations of the model noise process (assumed invertible)
%     h(t) = conditional variance of the innovations process e(t)
%
% We require R pre-sample lags of y(t), max(M,Q) pre-sample lags of e(t), and 
% P pre-sample lags of h(t) for GARCH & GJR conditional variance models, but 
% max(P,Q) pre-sample lags of h(t) for EGARCH conditional variance models. 
%
% To be safe, create max([R M P Q]) pre-sample lags for all conditional mean
% and conditional variance processes.
%

maxRMPQ  =  max([R M P Q]);   % maximum # of pre-sample lags needed to 'jump-start' the process.

%
% Determine whether valid pre-sample information is specified by the
% user and if the information is necessary.
%
% Set a Boolean convenience flag to indicate the absence of user-specified
% pre-sample conditioning information:
%
% isPreSampleMissing = 1 ---> Pre-sample data missing
%                    = 0 ---> Pre-sample data provided by the user
%
% Notes:
% (1) By default, no pre-sample conditioning information is assumed.
%     This implies that the simulation engine auto-generates it's own
%     pre-sample information via standard time series techniques.
% (2) Notice that pre-sample information is really only needed to 
%     jump-start recursive conditional mean and/or variance models. 
%     If neither the conditional mean nor conditional variance equation 
%     is recursive in any way, then no pre-sample information is needed 
%     to jump-start the models. In this case, specifying pre-sample 
%     information is redundant, but NOT an error, and any pre-sample 
%     observations specified for models that require no such information 
%     are simply ignored. 
% (3) If pre-sample data is specified, we require at least R pre-sample 
%     lags of y(t), at least max(M,Q) pre-sample lags of e(t), and at 
%     least P pre-sample lags of h(t) for GARCH & GJR conditional 
%     variance models, but max(P,Q) pre-sample lags of h(t) for EGARCH 
%     conditional variance models.
% (4) When the pre-sample information is provided and specified as column 
%     vectors, the vector is applied to each and every column of the 
%     corresponding Innovations, Sigmas, and Series time series outputs. 
%     In this situation, all simulated sample paths share a common 
%     conditioning set. This allows the simulated sample paths to evolve 
%     from a common starting point, and allows Monte Carlo simulation 
%     of forecasts and forecast error distributions. When pre-sample 
%     vectors are not specified, sample paths share no common conditioning 
%     set, resulting in entirely independent realizations.
%

isPreSampleMissing  =  logical(1);  % Initialize to 'missing user-specified pre-sample data'.

if (nargin >= 7)
%
%  Determine the number of pre-sample conditional standard deviations required.
%
   if strcmp(varianceModel , 'EGARCH')
%
%    'EGARCH' volatility models require at least max(P,Q) pre-sample 
%     observations of conditional standard deviations.
%
      nSTDs  =  max([P Q]);

   else
%
%    'GARCH', 'GJR', and 'Constant' volatility models require at least P
%     pre-sample observations of conditional standard deviations ('Constant'
%     volatility models will have P = 0).
%
      nSTDs  =  P;

   end
%
%  Determine which pre-sample information is required. If any pre-sample
%  data is needed, then update the missing pre-sample data flag.
%
   preInnovationsNeeded  =  logical(0);
   preSigmasNeeded       =  logical(0);
   preSeriesNeeded       =  logical(0);

   if (max([M Q]) > 0)
      preInnovationsNeeded =  logical(1);
      isPreSampleMissing   =  logical(0);  % Pre-sample data provided.
   end

   if (nSTDs > 0)
      preSigmasNeeded    =  logical(1);
      isPreSampleMissing =  logical(0);    % Pre-sample data provided.
   end

   if (R > 0) & (nargout >= 3)
      preSeriesNeeded     =  logical(1);
      isPreSampleMissing  =  logical(0);   % Pre-sample data provided.
   end

end

%
% If pre-sample conditioning observations are provided, then scrub the 
% pre-sample data. 
%
% In the error checking that follows, notice that the column oriented
% nature of a time series is strictly enforced. For this reason, each 
% pre-sample input {e0, s0, y0} MUST be either a column vector or a 
% matrix (i.e., an array of column vectors) with 'nPaths' columns. 
%
% With this interpretation, row vectors typically present an ambiguous 
% situation and are generally NOT allowed. The ONLY exception to this 
% may occur in situations in which only a single pre-sample observation 
% is required. In this situation, a user may specify a pre-sample matrix 
% with a single row, provided it has EXACTLY 'nPaths' columns. In this 
% case, although a pre-sample matrix with a single row is also a row 
% vector, it is dimensionally consistent and the pre-sample data is 
% still applied on column-by-column basis!
%

if ~isPreSampleMissing

%
%  Pre-allocate the pre-sample data arrays. Notice that all pre-sample 
%  conditioning arrays MUST have max([R M P Q]) rows for time index compatibility.
%

   preInnovations  =  zeros(maxRMPQ , nPaths);
   preSigmas       =  ones (maxRMPQ , nPaths);  % Set to 1's to prevent EGARCH divide by 0 warnings.
   preSeries       =  zeros(maxRMPQ , nPaths);

%
%  Scrub any required pre-sample conditioning information for the innovations e(t).
%

   if preInnovationsNeeded
      [preInnovations, message]  =  presamplecheck(preInnovations, 'PreInnovations', e0, max([M Q]));
      error(message);
   end

%
%  Scrub any required pre-sample conditioning information 
%  for the conditional standard deviations.
%

   if preSigmasNeeded

      if nargin >= 8
         [preSigmas, message]  =  presamplecheck(preSigmas, 'PreSigmas', s0, nSTDs);
         error(message);
      else
         error('GARCH:garchsim:UnspecifiedPreSigmas' , ' ''PreSigmas'' array must be specified.');
      end

      if any(preSigmas(:) <= 0)
         error('GARCH:garchsim:NonPositivePreSigmas' , ' All required ''PreSigmas'' standard deviations must be positive.');
      end

   end

%
%  Scrub any required pre-sample conditioning information for the return series y(t).
%

   if preSeriesNeeded

      if nargin >= 9
         [preSeries, message]  =  presamplecheck(preSeries, 'PreSeries', y0, R);
         error(message);
      else
         error('GARCH:garchsim:UnspecifiedPreSeries' , ' ''PreSeries'' array must be specified.');
      end

   end

end

%
% Determine the total number of observations to generate so time series arrays
% may be pre-allocated. This total will include the input sample size, the 
% pre-sample period, and any observations required to account for transients.   
%

if isPreSampleMissing

%
%  Independent Sample Path Simulation:
%
%  In the absence of user-specified pre-sample information, the appropriate 
%  conditional mean and/or variance models are viewed from a linear filtering 
%  perspective. We estimate the number of samples needed for the magnitude of 
%  the impulse response (which begins at 1) to decay below the input Tolerance 
%  parameter value (default is 0.01, or 1%). The estimate is based on the 
%  magnitude of the largest eigenvalue of the auto-regressive polynomial. 
%

%
%  Conditional Mean Models of ARMA(R,M) Form:
%
%  Estimate the number of samples it takes for the transients of an ARMA(R,M)
%  conditional mean process to die out, so the output process is in (approximately) 
%  steady-state. Notice that the transient effect of the mean model is common 
%  to all variance models.
%

   if isempty(AR)
      decayTime1  =  M;
   else
      eigenValues =  roots([1 -AR]);
      decayTime1  =  ceil(log(tolerance) / log(max(abs(eigenValues)))) + M;
   end

%
%  Conditional Variance Models:
%
%  For each type of volatility model, the particular conditional variance 
%  equation is re-arranged as an ARMA model:
%
%     GARCH(P,Q) for e(t) ---> ARMA(max(P,Q),P) process for e(t)^2
%       GJR(P,Q) for e(t) ---> ARMA(max(P,Q),P) process for e(t)^2
%    EGARCH(P,Q) for e(t) ---> ARMA(P,Q) process for log[h(t)]
%
%  Once the variance model is re-arranged as an ARMA model, we again estimate the
%  number of samples it takes for the transients of a conditional variance process 
%  to die out, so the output process is in (approximately) steady-state. 
%
   switch varianceModel

      case 'GARCH'

         if isempty(ARCH) & isempty(GARCH)
            decayTime2  =  P;
         else
            AB          =  zeros(max([P Q]) , 2);
            AB(1:Q,1)   =   -ARCH(:);
            AB(1:P,2)   =  -GARCH(:);
            polynomial  =  sum(AB,2);
            eigenValues =  roots([1 ; polynomial]);
            decayTime2  =  ceil(log(tolerance) / log(max(abs(eigenValues)))) + P;
         end


      case 'EGARCH'

         if isempty(GARCH)
            decayTime2  =  Q;
         else
            eigenValues =  roots([1 -GARCH]);
            decayTime2  =  ceil(log(tolerance) / log(max(abs(eigenValues)))) + Q;
         end


      case 'GJR'

         if isempty(ARCH) & isempty(GARCH)
            decayTime2  =  P;
         else
            AB          =  zeros(max([P Q]) , 2);
            AB(1:Q,1)   =  -(ARCH(:) + 0.5*Leverage(:));
            AB(1:P,2)   =  -GARCH(:);
            polynomial  =  sum(AB,2);
            eigenValues =  roots([1 ; polynomial]);
            decayTime2  =  ceil(log(tolerance) / log(max(abs(eigenValues)))) + P;
         end


      case 'Constant'

         decayTime2  =  0;

   end

%
%  Now compute the total number of observations generated for each path.
%

   T  =  nSamples  +  min(maxRMPQ  +  max(decayTime1 , decayTime2) , 10000);

else               % Dependent sample paths simulation.

%
%  Set the total number of observations generated for each path.
%
   T  =  nSamples  +  maxRMPQ;
%
%  Now size the innovations e(t) and conditional variance h(t) matrices and, if 
%  necessary, initialize with the input pre-samples specified by the user.
%
   e  =  zeros(T , nPaths);
   h  =  ones (T , nPaths);     % Set to 1's to prevent EGARCH divide by 0 warnings.

   if max([M Q]) ~= 0   %  Assign pre-sample values only if needed.
      e(1:maxRMPQ , :)  =  preInnovations;
   end

   if nSTDs ~= 0        %  Assign pre-sample values only if needed.
      h(1:maxRMPQ , :)  =  preSigmas.^2;   % Convert from standard deviation to variance.
   end

end

%
% Get the probability distribution of the innovations process and draw the 
% i.i.d. random sequence, y(t), that drives the e(t) innovations sequence 
% such that e(t) = y(t) * sqrt(h(t)).
%
% Note: 
%   There is a possible source of confusion here!
%
%   The code segment below assigns the i.i.d. random sequence to the temporary 
%   variable 'y'. Later on the same variable 'y' is used again to store the 
%   output simulated return series of interest (i.e., the output realization(s) 
%   of the conditional mean process referred to later on as y(t)).
%
%   Version 1.0 of the GARCH Toolbox called this same matrix of i.i.d. random 
%   disturbances 'v' instead of 'y' (i.e., the stochastic process was referred 
%   to as v(t) instead of y(t) as shown below).
%
%   Why is this happening?
%
%   As a general rule, this is considered poor programming style. However, 
%   large-scale Monte Carlo simulation consumes gobs of memory. Since the 
%   standardized innovations process v(t) and the output conditional mean 
%   process y(t) were ALWAYS the same size, the updated code below temporarily 
%   assigns the standardized innovations process to the variable 'y', then 
%   re-cycles the memory when 'y' is eventually used to house the output 
%   return series matrix 'y'. This cuts the memory consumed by large-scale
%   simulation by roughly 25 percent!
%

distribution  =  garchget(spec , 'Distribution');
distribution  =  distribution(~isspace(distribution));

switch upper(distribution)
   case 'GAUSSIAN'
      randn('state' , seed);
      y  =  randn(T , nPaths);           % y(t) are i.i.d. Gaussian variates ~ N(0,1) distributed.

   case 'T'
      DoF  =  garchget(spec , 'DoF');
      if isempty(DoF) 
         error('GARCH:garchsim:UnspecifiedDoF' , ' Degrees-of-freedom ''DoF'' of T-Distributed innovations must be specified.')
      end
      rand ('state' , seed);
      randn('state' , seed);

      y = randn(T , nPaths) .* sqrt(DoF ./ (randg(DoF/2 , T , nPaths) .* 2));
      y  =  y / sqrt(DoF / (DoF - 2));   % Standardize the  i.i.d. T-distributed variates.

   otherwise
      error('GARCH:garchsim:InvalidDistribution' , ' Distribution of innovations must be ''Gaussian'' or ''T''.')
end

%
% Construct the conditional variance parameter vector:
%
%     GARCH(P,Q) models require parameter vectors of length (1 + P +  Q).
%    EGARCH(P,Q) models require parameter vectors of length (1 + P + 2Q).
%       GJR(P,Q) models require parameter vectors of length (1 + P + 2Q).
%
%       Constant models only require the scalar parameter 'K'.
%

varianceCoefficients  =  [K ; GARCH(:) ; ARCH(:) ; Leverage(:)]';

%
% Form the h(t) conditional variance and e(t) innovations processes.
%
% Note on Independent Path Simulation:
%
%   The code below prepends maxRMPQ observations to each column of the e(t) 
%   and h(t) processes, thus (temporarily) increasing their sizes by maxRMPQ 
%   observations over and above what would otherwise be necessary. Also, each 
%   particular conditional variance model has unique pre-sample conditions 
%   that are considered in an effort to simultaneously minimize transients 
%   effects and manage memory.
%
%   Furthermore, in each model there appears to be a subtle discrepancy in the 
%   first maxRMPQ rows of the e(t) process and it's transformations (e.g., 
%   between e(t) and e(t)^2 for GARCH(P,Q) models, and between e(t) and |e(t)| 
%   for EGARCH(P,Q) models), and the h(t) process and it's transformations. 
%   These discrepancies are analogous to working with expectations in the 
%   pre-sample, and working with realizations in-sample.
%

switch varianceModel

%
%  Please note that at this point in the code:
%
%  y(t) = the i.i.d. random process (y(t) will later become the 
%         output return series of interest)
%  e(t) = innovations of the model noise process
%  h(t) = conditional variance of the innovations process e(t)
%

   case 'GARCH'
%
%     Pre-allocate & initialize the innovations e(t) and conditional 
%     variance h(t) processes for simulating independent paths (i.e., 
%     in the absence of user-specified pre-sample information).
%
      if isPreSampleMissing
%
%        Estimate the unconditional standard deviation of the invertible e(t) process.
%
         sigma  =  sqrt(K / (1 - sum([GARCH(:) ; ARCH(:)])));
%
%        The conditional expectation of e(t) = 0, while the conditional variance of 
%        e(t)^2 = h(t). In GARCH(P,Q) models, notice how the first maxRMPQ rows of
%        the innovations matrix e(t) actually drive the variance process h(t). In 
%        forming the h(t) process, lagged values of the innovations squared, e(t)^2, 
%        are actually filtered, and NOT the e(t) process itself.
%
%        For the purpose of simulating the e(t) and h(t) processes via the GARCH(P,Q)
%        conditional variance equation, Hamilton (top of page 667) suggests assigning 
%        the unconditional variance of e(t) to the first maxRMPQ observations of h(t) 
%        and e(t)^2. This implies that the unconditional standard deviation, SIGMA, is 
%        assigned to the first maxRMPQ observations of e(t) to facilitate jump-starting 
%        the variance process h(t). This introduces a pre-sample discrepancy in the e(t) 
%        process because we know the unconditional mean of e(t) = 0, yet we actually 
%        store SIGMA in the first maxRMPQ observations for convenience. Thus, we work 
%        with expectations in the pre-sample, and with realizations in-sample. The 
%        first maxRMPQ observations of the variance h(t) are set to the unconditional 
%        variance, SIGMA^2.
%
         e  =  repmat([sigma(ones(maxRMPQ,1)) ; zeros(T-maxRMPQ,1)] , 1 , nPaths);
         h  =  e.^2;

      end
%
%     Now filter the GARCH(P,Q) conditional variance equation.
%
      for t = (maxRMPQ + 1):T
          varianceData =  [ones(1,nPaths) ; h(t-(1:P),:) ; e(t-(1:Q),:).^2];
          h(t,:)       =  varianceCoefficients * varianceData;
          e(t,:)       =  sqrt(h(t,:)) .* y(t,:);
      end


   case 'EGARCH'
%
%     Determine the expected value of the absolute value (i.e., the mean 
%     absolute deviation, or MAD) of the appropriate standardized i.i.d. 
%     random sequence.
%
%     Note: Although there is no theoretical upper limit to the degree-of-freedom
%           parameter 'DoF', the GAMMA function rapidly approaches infinity as
%           'DoF' increases. To prevent a NaN (i.e., infinity/infinity) condition, 
%           bypass the calculation and simply replace the standardized T-distributed
%           mean absolute deviation by the asymptotic Gaussian limit. The allowable
%           upper limit is arbitrarily set at 200, well beyond the point at which
%           T and Gaussian distributions are essentially identical.
%
      if strcmpi(distribution , 'T') & (DoF <= 200)   % T-distributed innovations.
         MAD  =  sqrt((DoF - 2) / pi) * gamma(0.5 * (DoF - 1)) / gamma(0.5 * DoF);
      else
         MAD  =  sqrt(2 / pi);              % Gaussian innovations.
      end

%
%     Initialize pre-sample information for jump-starting the innovations e(t) and 
%     conditional variance h(t) processes.
%
      if isPreSampleMissing
%
%        Again, the conditional expectation of e(t) = 0, while the conditional variance of 
%        e(t)^2 = h(t). In EGARCH(P,Q) models, notice how the first maxRMPQ rows of
%        the innovations matrix e(t) actually drive the process log[h(t)]. EGARCH 
%        models form the log[h(t)] process by filtering lagged values of the standardized 
%        innovations, e(t)/sqrt(h(t)), and the absolute magnitude of the standardized 
%        innovations, |e(t)|/sqrt(h(t)).
%
%        For the purpose of simulating the e(t) and log[h(t)] processes via the 
%        EGARCH(P,Q) conditional variance equation, we compute the unconditional mean of
%        the log[h(t)] process by viewing it as an ARMA(P,Q) model. We then exponentiate
%        and take the square root, and call this quantity SIGMA. SIGMA may be loosely
%        interpreted as the unconditional standard deviation of the invertible e(t)
%        process, but it's really just the value used to initialize the h(t) process 
%        such that the pre-sample values of log[h(t)] minimize transients.
%
%        Initialize the innovations to ALL zeros. This ensures that the standardized
%        innovations (when computed recursively inside the filtering loop below) are
%        set to the unconditional expectation, E{e(t)} = 0, during the pre-sample 
%        start-up period.
%
         e  =  zeros(T , nPaths);
%
%        Estimate the SIGMA parameter to minimize transients.
%
         sigma  =  sqrt( exp(K / (1 - sum(GARCH(:)))) );
%
%        Initialize the conditional variance process h(t).
%
         h  =  repmat([sigma(ones(maxRMPQ,1)).^2 ; zeros(T-maxRMPQ,1)] , 1 , nPaths);
%
%        Over-write the i.i.d standardized sequence during the required pre-sample 
%        period with the mean absolute deviation. This ensures that the ARCH terms
%        are zero in the pre-sample period because the absolute magnitude of the 
%        standardized innovations are equal to the mean absolute deviation.
%
%        This introduces a pre-sample discrepancy between the innovations e(t) the 
%        i.i.d. standardized innovations y(t). Once the filtering moves beyond the
%        pre-sample period, the standardized innovations may be computed directly 
%        from the actual e(t) innovations process. Again, we minimize transients 
%        by working with expectations in the pre-sample, then work with realizations
%        in-sample.
%
         y(1:maxRMPQ,:)  =  MAD;

      else
%
%        When simulating dependent paths, we do NOT intentionally introduce any 
%        pre-sample discrepancies between the standardized innovations already 
%        stored in y(t) and those computed from e(t)/sqrt(h(t)).
%
         y(1:maxRMPQ,:)  =  e(1:maxRMPQ,:) ./ sqrt(h(1:maxRMPQ,:));

      end
%
%     Now filter the EGARCH(P,Q) conditional variance equation.
%
      for t = (maxRMPQ + 1):T

          if isPreSampleMissing
%
%            Compute the standardized innovations. Notice that, although y(t) already 
%            stores the standardized innovations, computing them from e(t) ensures the 
%            pre-sample expectation of E[e(t)] = 0 to minimize transients. 
%
%            When simulating independent paths, the pre-sample values of y(t) do NOT 
%            have this property. In this manner, we allow e(t) to handle the pre-sample 
%            expectation of the standardized innovations applied to the Leverage terms, 
%            while we allow y(t) to handle the pre-sample expectation of the absolute 
%            magnitude of the standardized innovations applied to the ARCH terms. 
%
             z  =  e(t-(1:Q),:) ./ sqrt(h(t-(1:Q),:));

          else
%
%            When simulating dependent paths, we do NOT intentionally introduce any 
%            pre-sample discrepancies between the standardized innovations already 
%            stored in y(t) and those computed from e(t)/sqrt(h(t)).
%
             z  =  y(t-(1:Q),:);

          end
%
%         Now, implement the EGARCH(P,Q) recursive equation. Since an EGARCH(P,Q) model 
%         is a recursive equation for the logarithm of the conditional variance, we must
%         exponentiate the result before storing it as the conditional variance in h(t).
%
          varianceData =  [ones(1,nPaths) ; log(h(t-(1:P),:)) ; (abs(y(t-(1:Q),:)) - MAD) ; z];
          h(t,:)       =  exp(varianceCoefficients * varianceData);
%
%         Finally, compute the simulated innovations e(t) associated with the EGARCH(P,Q) model.
%
          e(t,:)  =  sqrt(h(t,:)) .* y(t,:);

      end


   case 'GJR'
%
%     Pre-allocate & initialize the innovations e(t) and conditional 
%     variance h(t) processes for simulating independent paths (i.e., 
%     in the absence of user-specified pre-sample information).
%
      if isPreSampleMissing
%
%        Estimate the unconditional standard deviation of the invertible e(t) process.
%
         sigma  =  sqrt(K / (1 - sum([GARCH(:) ; ARCH(:) ; 0.5 * Leverage(:)])));
%
%        The conditional expectation of e(t) = 0, while the conditional variance of 
%        e(t)^2 = h(t). In GJR(P,Q) models, notice how the first maxRMPQ rows of
%        the innovations matrix e(t) actually drive the variance process h(t). In 
%        forming the h(t) process, lagged values of the innovations squared, e(t)^2, 
%        are actually filtered, and NOT the e(t) process itself. In this regard, 
%        GJR(P,Q) and GARCH(P,Q) models are identical.
%
%        However, GJR(P,Q) models add extra leverage terms that still filter the 
%        lagged values of the innovations squared, e(t)^2, but weight them with a 
%        Boolean indicator dependent upon the sign of the corresponding lags of e(t).
%        Thus, we need a mechanism whereby pre-sample expectations of e(t) AND e(t)^2
%        are handled without consuming memory.
%
%        For the purpose of simulating the e(t) and h(t) processes via the GJR(P,Q)
%        conditional variance equation, we follow the same approach as for GARCH(P,Q) 
%        models, and assign the unconditional variance of e(t) to the first maxRMPQ 
%        observations of h(t) and e(t)^2. This implies that the unconditional standard 
%        deviation, SIGMA, is assigned to the first maxRMPQ observations of e(t) to 
%        facilitate jump-starting the variance process h(t). 
%
%        This introduces a pre-sample discrepancy in the e(t) process because we 
%        know the unconditional mean of e(t) = 0, yet we actually store SIGMA in the 
%        first maxRMPQ observations for convenience. Thus, we work with expectations
%        in the pre-sample, and with realizations in-sample. As for GARCH(P,Q) models, 
%        the first maxRMPQ observations of the variance h(t) are set to the 
%        unconditional variance, SIGMA^2.
%
         e  =  repmat([sigma(ones(maxRMPQ,1)) ; zeros(T-maxRMPQ,1)] , 1 , nPaths);
         h  =  e.^2;

      end
%
%     Now filter the GJR(P,Q) conditional variance equation.
%
      for t = (maxRMPQ + 1):T
%
%         For independent paths, notice that the first maxRMPQ rows of e(t) are
%         initialized to the unconditional standard deviation, SIGMA, to facilitate 
%         jump-starting the variance process. However, since SIGMA is a positive 
%         number, the Boolean indicator evaluates to zero just as if the pre-sample 
%         observations of e(t) were initialized to zero (i.e., in pre-sample, the expected 
%         value of e(t) = 0 is effectively enforced by the Boolean indicator "(e1 < 0)").
%
          e1           =  e(t-(1:Q),:);  % Get the previous Q observations for GJR leverage effect.
          e2           =  e1.^2;

          varianceData =  [ones(1,nPaths) ; h(t-(1:P),:) ; e2 ; ((e1 < 0) .* e2)];
          h(t,:)       =  varianceCoefficients * varianceData;
          e(t,:)       =  sqrt(h(t,:)) .* y(t,:);
      end


   case 'Constant'
%
%     Pre-allocate & initialize the innovations e(t) and conditional 
%     variance h(t) processes.
%
      if isPreSampleMissing
%
%        If the user has specified pre-sample information, this has already done this.
%
         e  =  zeros(T , nPaths);

      end
%
%     The constant conditional variance of e(t) is always K.
%
      h  =  repmat(K , T , nPaths);
%
%     Scale the i.i.d sequence by the constant standard deviation.
%
      e((maxRMPQ + 1):T,:)  =  sqrt(h((maxRMPQ + 1):T,:)) .* y((maxRMPQ + 1):T,:);

end

%
% Now that the GARCH innovations e(t) have been simulated, run them through 
% a linear filter to generate a conditional mean of general ARMAX form.
%
% Notes:
% (1) From this point on, the variable 'y' (i.e., the y(t) process, assumed 
%     stationary) will now represent the conditional mean process, which is 
%     the eventual output return series of interest.
%
% (2) Regression models included in the conditional mean are ultimately based 
%     upon the presence of the explanatory data matrix X. Since the current 
%     version of the GARCH Toolbox allows for uni-variate models only, each 
%     column of the outputs ('e','h','y') represents a different realization 
%     (i.e., sample path) of the corresponding uni-variate stochastic process. 
%
%     However, in contrast to the outputs ('e','h','y'), the input explanatory 
%     matrix X is interpreted as a single realization of a (possibly) multi-variate 
%     regression matrix in which each column is a completely different time 
%     series.
%
%     This means that, when the conditional mean has a regression component, 
%     the entire explanatory matrix X (i.e., all columns of X) are applied
%     to each and every column (i.e., realization) of the output return series
%     matrix 'y'. 
%
%     For example, assume the output return series y(t) is a simple regression
%     model plus additive noise. In this case, the only difference between the 
%     columns of y(t) will be attributable to the innovations matrix e(t).
%
% (3) In preparation for ARIMA modeling in which the constant (C) in the 
%     conditional mean equation may NOT be desired, allow for the possibility
%     that C may be set to a NaN. In this case, a NaN sentinel value indicates 
%     that the constant C is excluded from the mean equation. 
%
%     Note that for simulation and forecasting purposes this is equivalent to 
%     setting C = 0. The real benefit of allowing C = NaN is for estimation, in
%     which the NaN sentinel value indicates that C is completely disregarded 
%     as a parameter in estimation process. Without allowing C = NaN, the only way 
%     that C may be excluded from the mean equation is to set C = 0 AND indicate
%     that it is an equality constraint, resulting in a more difficult estimation
%     problem.
%
%     Also note that C = NaN is fundamentally different from C = []. The former
%     means that C is NOT included in the mean equation, while the latter simply
%     means that C has not yet been specified but is otherwise included in the mean
%     equation. Put another way, for the purposes of simulation and forecasting, 
%     C = [] would be an error because a required parameter is unspecified.
%
% (4) SPECIAL NOTE: Simulation of Variance-in-Mean Models
%
%     In the code that follows, the 'InMean' parameter is a coupling coefficient
%     that allows inclusion of the conditional variance as an explanatory variable
%     in the conditional mean equation. The 'InMean' parameter field is applicable 
%     to all supported volatility models (i.e., GARCH-M, EGARCH-M, and GJR-M models).
%
%     However, when simulating GARCH-M, EGARCH-M, or GJR-M variance-in-mean models,
%     it is the conditional VARIANCE that is included in the mean equation.
%
%     Again, please note that simulation of GARCH-M, EGARCH-M, or GJR-M models is
%     an UNDOCUMENTED feature!
%

if nargout >= 3                     % Simulate y(t) only if requested.

%
%  If the conditional mean equation constant is NaN (i.e., Not-Applicable), then
%  set it to zero to get the desired effect without any additional special-purpose
%  code.
%
   if isnan(C)
      C  =  0;
   end

%
%  If explanatory data (i.e., a regression component) exists, pre-pend the 
%  sample mean of X if insufficient observations of the regressors exist to
%  accommodate the transient start-up period.
%

   if ~isempty(X)

      meanX  =  mean(X);                           % Sample mean vector.
      rowsX  =  size(X,1);                         % # of input observations.

      if T > rowsX
         X  =  [meanX(ones(T - rowsX , 1),:); X];  % Pre-pend the sample mean so we have T samples.
      else
         X  =  X(rowsX - (T - 1):end , :);         % Retain only the most recent T samples.
      end

   end

%
%  Initialize the output return series y(t) for subsequent linear filtering.
%

   if isPreSampleMissing
%
%     When simulating independent paths, the first maxRMPQ rows of e(t) are 
%     set to zero. This enforces the pre-sample expectation E{e(t)} = 0 to help 
%     minimize transients.
%
      e  =  [zeros(maxRMPQ,nPaths) ; e(maxRMPQ+1:end,:)];
%
%     Determine the appropriate model-dependent pre-sample values for y(t).
%
      average  =  C / (1 - sum(AR));   % Unconditional mean of stationary ARMA y(t) process.

      if isempty(X)

         if isVarianceInMean
%
%           We have no explanatory data (i.e., no regression component), so 
%           augment the ARMA unconditional mean with a Variance-in-Mean component.
%
            average =  average  +  (InMean * mean(h(:))) / (1 - sum(AR));

         end

      else
%
%        Augment the ARMA unconditional mean to incorporate the regressors 
%        and (if needed) the Variance-in-Mean component as well.
%
         if isVarianceInMean
            average =  average  +  ([regress InMean] * [meanX mean(h(:))]') / (1 - sum(AR));
         else
            average =  average  +  (regress * meanX') / (1 - sum(AR));
         end

      end
%
%     Pre-pend the unconditional mean to the y(t) process to minimize transients.
%
      y(1:maxRMPQ , :)  =  average;

   else
%
%     When simulating dependent paths, assign the user-specified pre-sample 
%     observations to the y(t) process, but only if necessary.
%
      if R ~= 0
         y(1:maxRMPQ , :)  =  preSeries;
      end

   end

%
%  Now that the pre-sample data has been formatted, compute the y(t) return 
%  series output. First, construct the ARMA portion of the conditional mean 
%  parameter vector of length (1 + R + (1 + M)) = (2 + R + M).
%

   armaCoefficients  =  [C ; AR(:) ; [1 ; MA(:)]]';

   if isempty(X)

      if isVarianceInMean
%
%        ARMA(R,M) + Variance-in-Mean model.
%
         for t = (maxRMPQ + 1):T
             armaData =  [ones(1,nPaths) ; y(t-(1:R),:) ; e(t-(0:M),:)];
             y(t,:)   =  (armaCoefficients * armaData)  +  (InMean * h(t,:));
         end

      else
%
%        ARMA(R,M) model only.
%
         for t = (maxRMPQ + 1):T
             armaData =  [ones(1,nPaths) ; y(t-(1:R),:) ; e(t-(0:M),:)];
             y(t,:)   =  armaCoefficients * armaData;
         end

      end

   else

      if (R + M) == 0               
%
%        Handle a simple regression as a special case. This is done simply
%        for run-time performance purposes only (i.e., since this is NOT a
%        recursive linear filter, we simulate a regression model with simple
%        matrix multiplication and matrix addition).
%
         y  =  repmat(C + X * regress' , 1 , nPaths)  +  e;

         if isVarianceInMean
%
%           Augment a regression model with a Variance-in-Mean component.
%
            y  =  y  +  h * InMean;

         end

      else

         if isVarianceInMean
%
%           ARMAX(R,M,Nx) + Variance-in-Mean model.
%
            for t = (maxRMPQ + 1):T
                armaData =  [ones(1,nPaths) ; y(t-(1:R),:) ; e(t-(0:M),:)];
                y(t,:)   =  (armaCoefficients * armaData)  +  (InMean * h(t,:))  +  (regress * X(t,:)');
            end

         else
%
%           ARMAX(R,M,Nx) model.
%
            for t = (maxRMPQ + 1):T
                armaData =  [ones(1,nPaths) ; y(t-(1:R),:) ; e(t-(0:M),:)];
                y(t,:)   =  (armaCoefficients * armaData)  +  (regress * X(t,:)');
            end

         end

      end

   end
%
%  Strip off the start-up period and retain only the last 'nSamples' observations.
%
   y  =  y((T - nSamples + 1):T , :);

end

%
% Since we have pre-pended maxRMPQ observations to the output processes 
% to compensate for transients and pre-sample effects, strip the start-up
% period and retain only the last 'nSamples' observations.
%

e  =  e((T - nSamples + 1):T , :);
h  =  h((T - nSamples + 1):T , :);

%
% Since h(t) is the conditional variance, convert it to a standard deviation.
%

h  =  sqrt(h);
