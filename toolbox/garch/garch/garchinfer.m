function [innovations , sigmas , LLF] = garchinfer(spec , y , X , e0 , s0 , y0)
%GARCHINFER Infer GARCH innovations processes from return series.
%   Given a conditional mean specification of ARMAX form and conditional
%   variance specification of GARCH, EGARCH, or GJR form, infer the 
%   innovations and conditional standard deviations from an observed 
%   univariate return series. Since GARCHINFER is an interface to the 
%   appropriate log-likelihood objective function, the log-likelihood value 
%   is also computed for convenience.
%
%   [Innovations, Sigmas, LLF] = garchinfer(Spec, Series)
%   [Innovations, Sigmas, LLF] = garchinfer(Spec, Series, X,
%     PreInnovations, PreSigmas, PreSeries)
%
%   Optional Input: X, PreInnovations, PreSigmas, PreSeries
%
% Inputs:
%   Spec - Structure specification for the conditional mean and variance 
%     models. Spec is a structure with fields generated by calling the 
%     function GARCHSET or GARCHFIT. Type "help garchset" for details.
%
%   Series - Time series matrix or column vector of observations of the 
%     underlying univariate return series of interest. Series is the response 
%     variable representing the time series fit to conditional mean and 
%     variance specifications. Each column of Series in an independent 
%     realization (i.e., path). The last row of Series holds the most recent 
%     observation of each realization.
%
% Optional Inputs:
%   X - Time series regression matrix of explanatory variable(s). Typically, X 
%     is a regression matrix of asset returns (e.g., the return series of an 
%     equity index). Each column of X is an individual time series used as an 
%     explanatory variable in the regression component of the conditional mean. 
%     In each column of X, the first row contains the oldest observation and 
%     the last row the most recent. If X is specified, the most recent number 
%     of valid (non-NaN) observations in each column of X must equal or exceed 
%     the most recent number of valid observations in Series. When the number 
%     of valid observations in each column of X exceeds that of Series, only 
%     the most recent observations of X are used. If empty or missing, the 
%     conditional mean will have no regression component.
%
%   PreInnovations - Time series matrix or column vector of pre-sample 
%     innovations upon which the recursive mean and variance models are 
%     conditioned. This array may have any number of rows, provided sufficient 
%     observations exist to initialize the mean and variance equations. 
%     Thus, if M and Q are the number of lagged innovations required by the 
%     conditional mean and variance equations, respectively, then the
%     PreInnovations array must have at least max(M,Q) rows. If the number of
%     rows exceeds max(M,Q), then only the last (i.e., most recent) max(M,Q)
%     rows are used as pre-sample observations. If PreInnovations is a matrix, 
%     then the number of columns must be the same as the number of columns 
%     in Series (see above). If PreInnovations is a column vector, then the 
%     vector is applied to each column (i.e., realization) of Series.
%
%   PreSigmas - Time series matrix or column vector of positive pre-sample 
%     conditional standard deviations upon which the recursive variance model 
%     is conditioned. This array may have any number of rows, provided 
%     sufficient observations exist to initialize the conditional variance 
%     equation. Thus, if P and Q are the number of lagged conditional standard 
%     deviations and lagged innovations required by the conditional variance 
%     equation, respectively, then the PreSigmas array must have at least P 
%     rows for GARCH and GJR models, and at least max(P,Q) rows for EGARCH 
%     models. If the number of rows exceeds the requirement, then only the 
%     last (i.e., most recent) rows are used as pre-sample observations. If 
%     PreSigmas is a matrix, then the number of columns must be the same as 
%     the number of columns in Series (see above). If PreSigmas is a column 
%     vector, then the vector is applied to each column (i.e., realization) 
%     of Series.
%
%   PreSeries - Time series matrix or column vector of pre-sample observations
%     of the return series of interest upon which the recursive mean model 
%     is conditioned. This array may have any number of rows, provided 
%     sufficient observations exist to initialize the conditional mean equation.
%     Thus, if R is the number of lagged observations of the return series 
%     required by the conditional mean equation, then the PreSeries array must
%     have at least R rows. If the number of rows exceeds R, then only the 
%     last (i.e., most recent) R rows are used as pre-sample observations. If 
%     PreSeries is a matrix, then the number of columns must be the same as 
%     the number of columns in Series (see above). If PreSeries is a column 
%     vector, then the vector is applied to each column (i.e., realization) 
%     of Series.
%
% Outputs:
%   Innovations - Innovations time series matrix inferred from the input 
%     Series. The size of Innovations is the same as the size of Series.
%
%   Sigmas - Conditional standard deviation time series matrix corresponding 
%     to Innovations. The size of Sigmas is the same as the size of Series.
%
%   LLF - Vector of log-likelihood objective function values for each 
%     realization of Series. The length of LLF is the same as the number 
%     of columns in Series.
%
% Notes:
% (1) When specified, the PreInnovations, PreSigmas, and PreSeries time series
%     arrays contain user-specified pre-sample observations used to infer the 
%     output arrays Innovations and Sigmas. When these arrays are specified 
%     and necessary, they MUST be specified together. This is an all-or-nothing
%     approach. In other words, if a user chooses to provide pre-sample data, 
%     then ALL necessary pre-sample data for ALL 3 arrays must be specified.
% (2) Although PreInnovations, PreSigmas, and PreSeries are companion inputs,
%     there are circumstances in which one or more may be empty. For example, a
%     GARCH(0,Q) (i.e., an ARCH(Q)) model does not require lagged conditional 
%     variances, and thus PreSigmas could be empty ([]). Similarly, PreSeries 
%     is only necessary when the mean equation has an auto-regressive component.
% (3) If the conditional mean and/or conditional variance equation is not 
%     recursive in any way, then certain pre-sample information is unnecessary
%     to jump-start the model(s). However, specifying redundant pre-sample 
%     information is NOT an error, and any pre-sample observations specified 
%     for models that require no such information are simply ignored.
% (4) When specified, the PreInnovations, PreSigmas, and PreSeries pre-sample 
%     arrays form the conditioning set used to initiate the inverse filtering, 
%     or inference, process. When these optional inputs are specified as 
%     matrices, the number of columns (realizations) of each MUST be the same
%     as the number of columns (realizations) of the Series input, in which 
%     case the pre-sample information of a given column is used to infer the 
%     residuals and standard deviations of the corresponding column of Series. 
%     When these inputs are specified as column vectors, the vector is applied 
%     to each column of Series. When no explicit pre-sample data is provided, 
%     the necessary pre-sample observations are derived by conventional time 
%     series techniques as outlined in the GARCH Toolbox User's Guide.
%
% See also GARCHSET, GARCHSIM, GARCHPRED, GARCHFIT.

%   Copyright 1999-2003 The MathWorks, Inc.   
%   $Revision: 1.12.4.1 $   $Date: 2003/05/08 21:45:24 $

%
% Scrub the input specification structure. This automatically upgrades 
% any GARCH Toolbox version 1.0 specification structures, and avoids any 
% constraint violations associated with user-specified initial guesses 
% or non-convergent structures gotten from previous GARCHFIT calls.
%

if ~isstruct(spec)
   error('GARCH:garchinfer:NonStructureInput' , ' ''Spec'' must be a structure.');
end

spec = garchset(spec);

%
% Check & scrub the observed return series matrix y(t).
%

if (nargin < 2)

   error('GARCH:garchinfer:UnspecifiedSeries' , ' Observed return series ''Series'' must be specified.');

else
%
%  For backward compatibility, allow for the possibility of a row vector 
%  as an input return series.
%
%  Although this is technically inconsistent with the documentation, the
%  presence of a row vector is deemed sufficiently unambiguous and is
%  interpreted as a single realization of a univariate time series (as 
%  opposed to multiple realizations of a univariate time series with
%  only a single observation in each realization ... which just does not
%  make sense!).
%
   rowY  =  logical(0);     

   if prod(size(y)) == length(y)   % Check for a vector (single return series).
      rowY  =  size(y,1) == 1;     % Flag a row vector for outputs.
      y     =  y(:);               % Convert to a column vector.
   end

%
%  The following code segment assumes that missing observations are indicated
%  by the presence of NaN's. Any initial rows with NaN's are removed, and 
%  processing proceeds with the remaining block of contiguous non-NaN rows. 
%  Put another way, NaN's are allowed, but they MUST appear as a contiguous 
%  sequence in the initial rows of the y(t) matrix. Since the log-likelihood 
%  functions are designed to process y(t) as a matrix (instead of individual 
%  vectors!), any initial rows with NaN's are stripped. Thus, realizations 
%  with no missing observations will lose data if other realizations have 
%  missing values.
%
   i1  =  find(isnan(y));
   i2  =  find(isnan(diff([y ; zeros(1,size(y,2))]) .* y));

   if (length(i1) ~= length(i2)) | any(i1 - i2)
      error('GARCH:garchinfer:MissingData' , ' Only initial observations in ''Series'' may be missing (NaN''s).')
   end

   if any(sum(isnan(y)) == size(y,1))
      error('GARCH:garchinfer:AllMissingData' , ' A realization of ''Series'' is completely missing (all NaN''s).')
   end

   firstValidRow  =  max(sum(isnan(y))) + 1;
   y              =  y(firstValidRow:end , :);

end

%
% Scrub the regression matrix and ensure the observed return series matrix y(t) 
% and the regression matrix X(t) have the same number of valid (i.e., non-NaN)
% rows (i.e., impose time index compatibility). During estimation, the innovations
% process e(t) must be inferred from the conditional mean specification, which 
% may include a regression component if desired. In contrast to simulation, 
% estimation of the innovations process e(t) is NOT independent of X. 
%

if (nargin >= 3) & ~isempty(X)

   if prod(size(X)) == length(X)   % Check for a vector.
      X  =  X(:);                  % Convert to a column vector.
   end
%
%  Retain the last contiguous block of non-NaN (i.e, non-missing valued) observations only. 
%
   if any(isnan(X(:)))
      X  =  X((max(find(isnan(sum(X,2)))) + 1):end , :);
   end

   if size(X,1) < size(y,1)
      error('GARCH:garchinfer:NotEnoughData' , ' Regression matrix ''X'' has insufficient number of observations.');
   else
      X  =  X(size(X,1) - (size(y,1) - 1):end , :);    % Retain only the most recent samples.
   end
%
%  Ensure number of regression coefficients match number of regressors.
%
   regress =  garchget(spec , 'Regress'); % Conditional mean regression coefficients.

   if size(X,2) ~= length(regress)
      error('GARCH:garchinfer:InputMismatch' , ' Number of ''Regress'' coefficients unequal to number of regressors in ''X''.');
   end

else

   X        =  [];   % Ensure X exists.
   regress  =  [];

end

%
% Ensure all coefficients exist and have proper dimensions.
%

R       =  garchget(spec , 'R');       % Conditional mean AR order.
M       =  garchget(spec , 'M');       % Conditional mean MA order.
P       =  garchget(spec , 'P');       % Conditional variance order for lagged variances.
Q       =  garchget(spec , 'Q');       % Conditional variance order for lagged residuals.

C       =  garchget(spec , 'C');       % Conditional mean constant.
AR      =  garchget(spec , 'AR');      % Conditional mean AR coefficients.
MA      =  garchget(spec , 'MA');      % Conditional mean MA coefficients.

K       =  garchget(spec , 'K');       % Conditional variance constant.
GARCH   =  garchget(spec , 'GARCH');   % Conditional variance coefficients for lagged variances.
ARCH    =  garchget(spec , 'ARCH');    % Conditional variance coefficients for lagged residuals.

if isempty(C)
   error('GARCH:garchinfer:UnspecifiedC' , ' Conditional mean constant ''C'' must be specified.');
end
if isempty(AR) & (R ~= 0)
   error('GARCH:garchinfer:UnspecifiedAR' , ' Auto-regressive ''AR'' coefficients must be specified.');
end
if isempty(MA) & (M ~= 0)
   error('GARCH:garchinfer:UnspecifiedMA' , ' Moving-average ''MA'' coefficients must be specified.');
end
if isempty(K)
   error('GARCH:garchinfer:UnspecifiedK' , ' Conditional variance constant ''K'' must be specified.');
end
if isempty(GARCH) & (P ~= 0)
   error('GARCH:garchinfer:UnspecifiedGARCH' , ' ''GARCH'' coefficients of lagged variances must be specified.');
end
if isempty(ARCH)  & (Q ~= 0)
   error('GARCH:garchinfer:UnspecifiedARCH' , ' ''ARCH'' coefficients of lagged residuals must be specified.');
end

%
% Ensure the variance model specification is complete.
%
% SPECIAL NOTE ON UNDOCUMENTED FEATURES: Variance-in-Mean Models
%
% The presence of an appended dash (i.e., '-') in the 'VarianceModel' field 
% is an indication that the conditional variance is included as an explanatory 
% variable in the conditional mean equation. 
%
% Please note that inference/estimation of residuals in the presence of 
% variance-in-mean conditions is allowed ONLY for conditional variance models 
% of GARCH-M form. In other words, inference of variance-in-mean models are 
% allowed ONLY if the conditional variance equation is described by a GARCH(P,Q) 
% model. Conditional variances derived from EGARCH(P,Q) and GJR(P,Q) variance 
% models are NOT allowed to enter the mean equation for inference/estimation 
% purposes. This is in contrast to simulation applications, in which variance-in-mean
% models are allowed for GARCH-M, EGARCH-M, and GJR-M models.
%
% In addition to the fields formally documented, the GARCH Toolbox specification 
% structure supports the following UNDOCUMENTED parameters:
%
%       InMean - Scalar coefficient for variance-in-mean models. 
%                [ scalar coefficient | {[]} ]
%    FixInMean - Equality constraint indicator for InMean coefficient.
%                [ logical scalar | {[]} ]
%
% In the code that follows, the 'InMean' parameter is a coupling coefficient
% that allows inclusion of the conditional variance as an explanatory variable
% in the conditional mean equation. For inference/estimation purposes, the 
% 'InMean' parameter field is applicable ONLY to GARCH-M models.
%
% Again, inference/estimation of GARCH-M models is an UNDOCUMENTED feature!
%

varianceModel  =  garchget(spec , 'VarianceModel');

[varianceModel , InMeanString] = strtok(varianceModel , '-');

isVarianceInMean = ~isempty(InMeanString);
InMean           =  garchget(spec , 'InMean');

if isVarianceInMean
   if ~any(strcmp(upper(varianceModel) , {'GARCH' 'CONSTANT'}))
      error('GARCH:garchinfer:InvalidFunctionality' , ' EGARCH-M and GJR-M variance-in-mean models are NOT allowed.');
   end
   if isempty(InMean)
      error('GARCH:garchinfer:UnspecifiedInMean' , ' Variance-in-mean coefficient ''InMean'' must be specified.');
   end
end

%
% Ensure that Leverage coefficients are specified for 
% the asymmetric EGARCH and GJR models.
%

Leverage  =  garchget(spec , 'Leverage');

if strcmp(varianceModel , 'EGARCH') | strcmp(varianceModel , 'GJR')

   if isempty(Leverage)  & (Q ~= 0)
      error('GARCH:garchinfer:UnspecifiedLeverage' , ' ''Leverage'' coefficients must be specified for ''EGARCH'' and ''GJR'' models.');
   end

end

%
% Determine whether valid pre-sample information is specified and necessary.
%
% Let y(t) = return series of interest (assumed stationary)
%     e(t) = innovations of the model noise process (assumed invertible)
%     h(t) = conditional variance of the innovations process e(t)
%
% Set a Boolean convenience flag to indicate the absence of user-specified
% pre-sample conditioning information:
%
% isPreSampleMissing = 1 ---> Pre-sample data missing
%                    = 0 ---> Pre-sample data provided by the user
%
% Notes:
% (1) By default, no pre-sample conditioning information is assumed.
%     This implies that the inference routines auto-generate their own
%     pre-sample information via standard time series techniques.
% (2) Notice that pre-sample information is really only needed to 
%     jump-start recursive conditional mean and/or variance models. 
%     If neither the conditional mean nor conditional variance equation 
%     is recursive in any way, then no pre-sample information is needed 
%     to jump-start the models. In this case, specifying pre-sample 
%     information is redundant, but NOT an error, and any pre-sample 
%     observations specified for models that require no such information 
%     are simply ignored. 
% (3) If pre-sample data is specified, we require at least R pre-sample 
%     lags of y(t), at least max(M,Q) pre-sample lags of e(t), and at 
%     least P pre-sample lags of h(t) for GARCH & GJR conditional 
%     variance models, but max(P,Q) pre-sample lags of h(t) for EGARCH 
%     conditional variance models.
%

isPreSampleMissing  =  logical(1);  % Initialize to 'missing user-specified pre-sample data'.

if (nargin >= 4)
%
%  Determine the number of pre-sample conditional standard deviations required.
%
   if strcmp(upper(varianceModel) , 'EGARCH')
%
%    'EGARCH' volatility models require at least max(P,Q) pre-sample 
%     observations of conditional standard deviations.
%
      nSTDs  =  max([P Q]);

   else
%
%    'GARCH', 'GJR', and 'Constant' volatility models require at least P
%     pre-sample observations of conditional standard deviations ('Constant'
%     volatility models will have P = 0).
%
      nSTDs  =  P;

   end
%
%  Determine which pre-sample information is required. If any pre-sample
%  data is needed, then update the missing pre-sample data flag.
%
   preInnovationsNeeded  =  logical(0);
   preSigmasNeeded       =  logical(0);
   preSeriesNeeded       =  logical(0);

   if (max([M Q]) > 0)
      preInnovationsNeeded =  logical(1);
      isPreSampleMissing   =  logical(0);  % Pre-sample data provided.
   end

   if (nSTDs > 0)
      preSigmasNeeded    =  logical(1);
      isPreSampleMissing =  logical(0);    % Pre-sample data provided.
   end

   if (R > 0)
      preSeriesNeeded    =  logical(1);
      isPreSampleMissing =  logical(0);    % Pre-sample data provided.
   end

end

%
% If pre-sample conditioning observations are provided, then scrub the 
% pre-sample data. 
%
% In the error checking that follows, notice that the column oriented
% nature of a time series is strictly enforced. For this reason, each 
% pre-sample input {e0, s0, y0} MUST be either a column vector or a 
% matrix (i.e., an array of column vectors) with the same number of 
% columns as the input return series. 
%
% With this interpretation, row vectors typically present an ambiguous 
% situation and are generally NOT allowed. The ONLY exception to this 
% may occur in situations in which only a single pre-sample observation 
% is required. In this situation, a user may specify a pre-sample matrix 
% with a single row, provided it has EXACTLY the same number of columns
% as the input return series matrix. In this case, although a pre-sample
% matrix with a single row is also a row vector, it is dimensionally 
% consistent and the pre-sample data is still applied on column-by-column
% basis!
%

if isPreSampleMissing

%
%  If no pre-sample data is provided, then initialize ALL the pre-sample
%  arrays to empty matrices. This is done simply so that calls to the
%  log-likelihood objective functions have the same calling syntax.
%
   preInnovations  =  [];
   preSigmas       =  [];
   preSeries       =  [];

else

%
%  Pre-allocate the pre-sample data arrays. Notice that all pre-sample 
%  conditioning arrays, if provided, MUST have max([R M P Q]) rows for 
%  time index compatibility. This is required by the log-likelihood 
%  objective functions.
%
   maxRMPQ  =  max([R M P Q]);      % # of rows in pre-sample arrays
   nPaths   =  size(y , 2);         % # of columns in pre-sample arrays

   preInnovations  =  zeros(maxRMPQ , nPaths);
   preSigmas       =  ones (maxRMPQ , nPaths);  % Set to 1's to prevent incorrectly trapping errors below.
   preSeries       =  zeros(maxRMPQ , nPaths);

%
%  Scrub any required pre-sample conditioning information for the innovations e(t).
%
   if preInnovationsNeeded
      [preInnovations, message]  =  presamplecheck(preInnovations, 'PreInnovations', e0, max([M Q]));
      error(message);
   end
%
%  Scrub any required pre-sample conditioning information 
%  for the conditional standard deviations.
%
   if preSigmasNeeded

      if nargin >= 5
         [preSigmas, message]  =  presamplecheck(preSigmas, 'PreSigmas', s0, nSTDs);
         error(message);
      else
         error('GARCH:garchinfer:UnspecifiedPreSigmas' , ' ''PreSigmas'' array must be specified.');
      end

      if any(preSigmas(:) <= 0)
         error('GARCH:garchinfer:NonPositivePreSigmas' , ' All required ''PreSigmas'' standard deviations must be positive.');
      end

   end
%
%  Scrub any required pre-sample conditioning information for the return series y(t).
%
   if preSeriesNeeded

      if nargin >= 6
         [preSeries, message]  =  presamplecheck(preSeries, 'PreSeries', y0, R);
         error(message);
      else
         error('GARCH:garchinfer:UnspecifiedPreSeries' , ' ''PreSeries'' array must be specified.');
      end

   end

end

%
% Infer the innovations (i.e., residuals) and the corresponding conditional 
% standard deviations via the inverse filtering operation. This is performed 
% by calling the appropriate log-likelihood objective function.
%
% Notes:
% (1) Please be aware that the purpose of the objective functions called 
%     below is to support numerical optimization (see GARCHFIT). For this
%     reason, the code segment below is slightly awkward simply because
%     GARCHINFER is really meant to be a convenience wrapper around the 
%     appropriate log-likelihood objective function.
% (2) The coefficient vector 'Parameters' passed to the objective functions 
%     contains ONLY those parameters known to the numerical optimizer FMINCON
%     of the Optimization Toolbox. To understand exactly how the parameter 
%     vector is formatted, refer to the relevant objective function.
% (3) Although inference/estimation of residuals is independent of the 
%     probability distribution of the residuals, the calculation of the 
%     log-likelihood function value 'LLF' is NOT. For this reason, the 
%     outer SWITCH statement is based on the distribution.
% (4) Aside from the degree-of-freedom 'DoF' parameter for T distributions, 
%     the coefficient vector 'Parameters' is formatted in the same manner 
%     for GARCH, EGARCH, and GJR variance models. Be aware that when the 
%     'Parameters' vector is packed, certain coefficients are in fact empty.
%     For example, GARCH variance models have empty 'Leverage' terms since
%     these terms do not apply. Also, ONLY GARCH-M  models allow for a
%     variance-in-mean term, but the 'InMean' coefficient will be empty
%     for EGARCH-M and GJR-M models.
%

%
% Determine whether or not to include the conditional mean constant 'C' in the parameter vector.
%
if isnan(C)
%
%  A NaN sentinel indicates that the constant 'C' is NOT an estimated parameter.
%
   Parameters       = [    AR(:) ; MA(:) ; regress(:) ; InMean ; K ; GARCH(:) ; ARCH(:) ; Leverage(:)];
   isConstantInMean = logical(0);
else
%
%  The constant 'C' is an estimated parameter, so place it in the first element.
%
   Parameters       = [C ; AR(:) ; MA(:) ; regress(:) ; InMean ; K ; GARCH(:) ; ARCH(:) ; Leverage(:)];
   isConstantInMean = logical(1);
end

%
% Get the probability distribution of the innovations process e(t) 
% and call the appropriate log-likelihood objective function.
%

distribution  =  garchget(spec , 'Distribution');
distribution  =  distribution(~isspace(distribution));


switch upper(distribution)

   case 'GAUSSIAN'
%
%     Now call the appropriate objective function for Gaussian residuals.
%     
%
      switch upper(varianceModel)

         case {'GARCH' , 'CONSTANT'}           % GARCH(0,0) and Constant variance models are the same thing.
            objectiveFunction  =  @garchllfn;

         case 'EGARCH'
            objectiveFunction  =  @egarchllfn;
            isVarianceInMean   =  logical(0);  % Just to safe.

         case 'GJR'
            objectiveFunction  =  @gjrllfn;
            isVarianceInMean   =  logical(0);  % Just to safe.
      end

   case 'T'
%
%     Student T distributions require estimation of the degree-of-freedom parameter 'DoF'.
%
      DoF  =  garchget(spec , 'DoF');          % Degrees-of-Freedom for T-distributions.

      if isempty(DoF)
         error('GARCH:garchinfer:UnspecifiedDoF' , ' Degrees-of-freedom ''DoF'' must be specified for T-distributions.');
      end

      Parameters  =  [Parameters ; DoF];       % Add the degree-of-freedom parameter to the end of the list.

%
%     Now call the appropriate objective function for T-distributed residuals.
%
      switch upper(varianceModel)

         case {'GARCH' , 'CONSTANT'}           % GARCH(0,0) and Constant variance models are the same thing.
            objectiveFunction  =  @garchllft;

         case 'EGARCH'
            objectiveFunction  =  @egarchllft;
            isVarianceInMean   =  logical(0);  % Just to safe.

         case 'GJR'
            objectiveFunction  =  @gjrllft;
            isVarianceInMean   =  logical(0);  % Just to safe.

      end

   otherwise

      error('GARCH:garchinfer:InvalidDistribution' , ' Distribution of innovations must be ''Gaussian'' or ''T''.')

end

[LLF, G, H, innovations, sigmas] = feval(objectiveFunction, Parameters, y, R, M, P, Q, X, isConstantInMean, isVarianceInMean, ...
                                         preInnovations   , preSigmas , preSeries);

%
% Negate objective function value to compensate for the minimization function FMINCON.
%

LLF  =  -LLF;

%
% Re-format outputs for compatibility with the SERIES input. When 
% SERIES is input as a single row vector, then pass the outputs 
% as a row vectors. 
%

if rowY
   innovations  =  innovations(:).';
   sigmas       =  sigmas(:).';
end
