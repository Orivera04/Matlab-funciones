function [out,profptr] = hmmprofgenerate(model,varargin)
%HMMPROFGENERATE generates a random sequence using a profile HMM.
%
%   [SEQUENCE] = HMMPROFGENERATE(MODEL) returns a string showing a sequence
%   of amino acids (or nucleotides) drawn from the profile MODEL. The
%   length, alphabet, and probabilities of the MODEL are stored in a 
%   structure. For more details on the structure, see HMMPROFSTRUCT.
%
%   [SEQUENCE,PROFPTR] = HMMPROFGENERATE(MODEL) returns a vector of the
%   same length as the profile model with indices pointing to the respective
%   symbols in the output sequence. Null pointers (NaN) mean that such
%   states do not emit a symbol in the output sequence, either because they
%   represent model jumps from the BEGIN state to a MATCH state or from a
%   MATCH state to the END state, or because the output sequence passed
%   through DELETE states.
%
%   HMMPROFGENERATE(...,'ALIGN',align_flag) if align_flag is true
%   (default), then the output sequence is aligned to the model as follows:
%   Capital letters and dashes correspond to MATCH and DELETE states
%   respectively (the combined count is equal to the number of states in
%   the model). Lowercase letters are emitted by the INSERT or FLANKING
%   INSERT states. If align_flag is false, then the first output is a plain
%   sequence of uppercase symbols, and the second output will contain
%   pointers to this sequence where profile states which generate no
%   symbols are indicated by a null (NaN) pointer. 
%
%   HMMPROFGENERATE(...,'FLANKS',true) includes the symbols generated by
%   the FLANKING INSERT states in the output sequence. 
%
%   HMMPROFGENERATE(...,'SIGNATURE',true) returns the most likely path and
%   symbols.  
%
%   Note: Repeated domains are not supported. This means that the model
%   can not pass through the 'joining' segment between the 'End' and the
%   'Begin' states.
%
%   Example:
%
%     load('hmm_model_examples','model_7tm_2') % load a model example
%     rand_sequence = hmmprofgenerate(model_7tm_2)
%
%   See also HMMPROFALIGN, HMMPROFSTRUCT, SHOWHMMPROF.

%   Copyright 2003-2004 The MathWorks, Inc.
%   $Revision: 1.9.6.4 $  $Date: 2004/04/01 15:58:01 $
%

% Validate HMM model:
try   
    model = checkhmmprof(model);
catch 
    rethrow(lasterror);
end

% default varargin
outputaligned = true;
includeflanks = false;
signature = false;

% check varargin
if nargin > 1
    if rem(nargin,2) == 0
        error('Bioinfo:IncorrectNumberOfArguments','Incorrect number of arguments to %s.',mfilename);
    end
    okargs = {'align','flanks','signature'};
    for j=1:2:nargin-2
        pname = varargin{j};
        pval = varargin{j+1};
        k = strmatch(lower(pname), okargs);
        if isempty(k)
            error('Bioinfo:UnknownParameterName','Unknown parameter name: %s.',pname);
        elseif length(k)>1
            error('Bioinfo:AmbigousParameterName','Ambiguous parameter name: %s.',pname);
        else
            switch(k)
                case 1,  outputaligned = pval == true;
                case 2,  includeflanks = pval == true;
                case 3,  signature = pval == true;
            end
        end %if k==1
    end % for all varargin
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% reading in model structure
profLength=model.ModelLength;
switch upper(model.Alphabet)
    case 'AA', alphaLength=20;
    case 'NT', alphaLength=4;
end
%% NULL MODEL EMISSION LOG-PROB (nep)
nep=model.NullEmission;
%% MATCH EMISSION LOG-PROB (mep)
mep=model.MatchEmission;
%% INSERT EMISSION LOG-PROB (iep)
iep=[nep;model.InsertEmission(1:end-1,:);nep];
%% MATCH TRANSITION LOG-PROB (mxp)
mxp=model.MatchX;
%% INSERT TRANSITION LOG-PROB (ixp)
ixp=model.InsertX;
%% DELETE TRANSITION LOG-PROB (dxp)
dxp=model.DeleteX;
%% BEGIN-[DEL_1-MATCH_X] TRANSITION LOG-PROB (bxp)
%% [xBD1, xBM1, xBM2, xBM3, xBM4 ... ]
bxp=model.BeginX;
%% LEFT-INSERT TRANSITIONS LOG-PROB VECTOR (lixp)
%% [xNB ; xNN ]
lixp=model.FlankingInsertX(:,1);
%% RIGTH-INSERT TRANSITIONS LOG-PROB VECTOR (rixp)
%% [xCT ; xCC ]
rixp=model.FlankingInsertX(:,2);
% reading in model structure (end)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% GENERATING TRANSITIONS FOR THE SIGNATURE OR RANDOM TRANSITIONS
if signature
    [dump,mxd] = max(mxp,[],2);
    [dump,dxd] = max(dxp,[],2);
    if includeflanks
        ixnd = ones(profLength+1,1);
    else
        ixnd = [0 ; ones(profLength-1,1) ; 0];
    end
else
    mxd = min(4,sum(cumsum(mxp,2)<repmat(rand(profLength-1,1),1,4),2)+1);
    dxd = min(2,sum(cumsum(dxp,2)<repmat(rand(profLength-1,1),1,2),2)+1);
    if includeflanks
        ixnd = ceil(log(rand(profLength+1,1))./log([lixp(2);ixp(:,1);rixp(2)]));
    else
        ixnd = [0;ceil(log(rand(profLength-1,1))./log(ixp(:,1)));0];
    end
end

% TRAVELING TROUGHT THE PATH
profptr=zeros(1,profLength);
DelFlag=ones(1,profLength);

si=1;                                        % init out seq index
si=si+ixnd(1);                               % add left flanking inserts
if signature
    [dump,pi] = max(bxp);
    pi=pi-1;
else
    pi=min(profLength,sum(cumsum(bxp)<rand(1))); % select at which D1-Mx begin
end
if pi % starts at a Mx state, only insert deletes
    DelFlag(1:pi-1)=true;                     % D states flagged
    profptr(1:pi-1)=si:si+pi-2;               % pointers to D states
    si=si+pi-1;                               % next avail. position in out seq
    inM=true;                                 % next state is M
else % pi==0 starts at D1
    inM=false;                                % next state is D
    pi=1;                                     % next prof num is 1
end

while pi<profLength
    profptr(pi)=si;
    DelFlag(pi)=~inM;
    %%% Now test for transition drawn
    if inM  %in M state
        switch mxd(pi)
            case 1, pi=pi+1;si=si+1;inM=true;
            case 2, pi=pi+1;si=si+ixnd(pi)+1;inM=true;
            case 3, pi=pi+1;si=si+1;inM=false;
            case 4, profptr(pi:profLength-1)=si:si+profLength-pi-1;
                si=si+profLength-pi; pi=profLength; inM=false;
        end
    else  %in D state
        switch dxd(pi)
            case 1, pi=pi+1;si=si+1;inM=true;
            case 2, pi=pi+1;si=si+1;inM=false;
        end
    end
end
profptr(pi)=si;                              %last state in profile
DelFlag(pi)=~inM;
si=si+ixnd(end);                             %add rigth flanking inserts

% DRAW SYMBOLS TO FILL INSERT STATES

out=repmat('-',1,si);                        %init output sequence with all deletes
insertlocs=[0 profptr si+1];                 %find where to insert
insertinds=[(insertlocs(1:end-1)+1);(insertlocs(2:end)-1)];
for h=find(1+diff(insertinds))
    switch upper(model.Alphabet)
        case 'AA', if signature
                [dump,ms] = max(iep(h,:));
                out(insertinds(1,h)) = lower(int2aa(ms));
            else
                out(insertinds(1,h):insertinds(2,h)) = lower(int2aa(min(alphaLength,...
                    sum(repmat(cumsum(iep(h,:)),ixnd(h),1)<repmat(rand(ixnd(h),1),1,alphaLength),2)+1)'));
            end
        case 'NT', if signature
                [dump,ms] = max(iep(h,:));
                out(insertinds(1,h)) = lower(int2nt(ms));
            else
                out(insertinds(1,h):insertinds(2,h)) = lower(int2nt(min(alphaLength,...
                    sum(repmat(cumsum(iep(h,:)),ixnd(h),1)<repmat(rand(ixnd(h),1),1,alphaLength),2)+1)'));
            end
    end
end

% DRAW SYMBOLS TO FILL MATCH STATES
h=find(~DelFlag);
switch upper(model.Alphabet)
    case 'AA', if signature
            [dump,ms] = max(mep(h,:),[],2);
            out(profptr(h)) = int2aa(ms);
        else
            out(profptr(h))=int2aa(min(alphaLength,...
                sum(cumsum(mep(h,:),2)<repmat(rand(length(h),1),1,alphaLength),2)+1)');
        end
    case 'NT', if signature
            [dump,ms] = max(mep(h,:),[],2);
            out(profptr(h)) = int2nt(ms);
        else
            out(profptr(h))=int2nt(min(alphaLength,...
                sum(cumsum(mep(h,:),2)<repmat(rand(length(h),1),1,alphaLength),2)+1)');
        end
end

if ~outputaligned
    out(profptr(logical(DelFlag)))=[];
    out=upper(out);
    profptr=profptr-cumsum(DelFlag);
    profptr(logical(DelFlag))=NaN;
end

