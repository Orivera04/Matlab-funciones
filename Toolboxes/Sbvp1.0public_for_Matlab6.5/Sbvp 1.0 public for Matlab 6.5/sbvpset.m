function options = sbvpset(varargin)
% SBVPSET Create/alter BVP OPTIONS structure
%
%   BVPOPT = SBVPSET('NAME1',VALUE1,'NAME2',VALUE2,...) creates an
%   options structure BVPOPT in which the named properties have
%   the specified values. Any unspecified properties have default values.
%   It is sufficient to type only the leading characters that uniquely
%   identify the property.  Case is ignored for property names.
%   
%   BVPOPT = SBVPSET(OLDOPT,'NAME1',VALUE1,...) alters an existing options
%   structure OLDOPT.
%   
%   BVPOPT = SBVPSET(OLDOPT,NEWOPT) combines an existing options structure
%   OLDOPT with a new options structure NEWOPT.  Any new properties
%   overwrite corresponding old properties.
%   
%   SBVPSET with no input arguments displays all property names and their
%   possible values.
%   
% SBVPSET PROPERTIES
%   
% RelTol - Relative error tolerance  [ nonnegative scalar {1e-3} ]
%   This scalar applies to all components of the solution vector, and
%   defaults to 1e-3 (0.1% accuracy). The estimated error e(t) on the final mesh
%   satisfies 
%      max_t (|e(t)| / (AbsTol + |y(t)| * RelTol)) < 1
%
% AbsTol - Absolute error tolerance  [ positive scalar {1e-6} ]
%   This scalar applies to all components of the solution vector, and
%   defaults to 1e-6.  The estimated error on the final mesh satisfies 
%      max_t (|e(t)| / (AbsTol + |y(t)| * RelTol)) < 1
%
% MaxMeshPts - Maximum number of mesh points [ integer {10000} ]
%
% IntMaxMinRatio - Upper limit to the quotient of the length of the longest
%   and shortest subinterval in the final mesh produced by SBVP [positive scalar {10}].
%
% CheckJac - Compare user supplied Jacobians to finite-difference approximations [ {0} | 1 ]
%
% fVectorized - Vectorized f-evaluation [ {0} | 1 ]
%   Set this property if the BVPFILE is coded such that BVPFILE('f',[t1 t2 ...],[y1 y2 ...])
%   returns [f(t1,y1) f(t2,y2) ...].
%
% JacVectorized - Vectorized Jacobian-evaluation [ {0} | 1 ]
%   Set this property if the BVPFILE is coded such that BVPFILE('df/dy',[t1 t2 ...],[y1 y2 ...])
%   returns [f'(t1,y1) f'(t2,y2) ...], or alternatively a threedimensional array J where
%   J(:,:,i) contains f'(ti,yi).
%
% Basis - Basis of collocation polynomials [ {RungeKutta} | Lagrange | Legendre | Monomial ]
%
% ColPts - Distribution of collocation points  [ {equidistant} | gauss |  numerical vector on [0,1] ]
%
% Degree - Highest degree of basis polynomials [ integer 1-8 {4} ]
%   Using SBVP, the collocation degree is set to the value of this property if the value 
%   of 'DegreeSelect' is 'manual'. Otherwise, the collocation degree is determined from 
%   the tolerances automatically. 
%
% DegreeSelect - Selection mode of basis polynomial degree [ {auto} | manual]
%   Used by SBVP and ignored by SBVPCOL.
%
% Display - Display information about the solution process [ 0 | {1} ]
%
% ZfMethod - Zerofinder method for nonlinear BVPs [ {Newton} | FSolve ]
%   'Newton' forces the use of damped Newton iteration, 'FSolve' uses the zerofinder
%   provided by MATLAB.
%
% ZfOpt - Parameter struct used by the zerofinding routines [ struct ]
%   ZfOpt holds tolerances, termination conditions, etc. and should be
%   generated by OPTIMSET. See OPTIMSET and the example below for further information.
%
% OutputFcn - Function handle or name of output function  [ handle/string ]
%   OFs are used to display intermediate results of the mesh adaption process.
%   The predefined OFs SBVPPLOT, SBVPPHAS2 and SBVPPHAS3 all display the 
%   the solution approximation on the current mesh in order to illustrate the adaption 
%   process graphically. SBVPPLOT simply draws the solution components versus t, SBVPPHAS2 
%   and SBVPPHAS3 plot 2- and 3-dimensional phase portraits, respectively. 
%
% OutputSel - Output selection indices  [ vector of integers ]
%   This vector of indices specifies which components of the approximation vector Y
%   are passed to the OutputFcn. OutputSel defaults to all components.
%
% OutputTrace - Pause after each mesh adaption step [ 0 | {1} ]
%
%
% Example:
%   my_zerofinder_options = optimset('TolX',1e-8,'TolFun',1e-6,'MaxFunEvals',50);
%
%   my_bvp_options = sbvpset('ZfOpt',my_zerofinder_options);
%
%
%   See also SBVP  SBVPCOL  OPTIMSET  SBVPPLOT  SBVPPHAS2  SBVPPHAS3

%   Copyright (c) 2003 Winfried Auzinger
%                      Guenter Kneisl
%                      Othmar Koch
%                      Ewa Weinmueller
%                      Vienna University of Technology

% Print out possible values of properties.
if (nargin == 0) & (nargout == 0)
  fprintf('           AbsTol: [ positive scalar {1e-6} ]\n');
  fprintf('            Basis: [ {RungeKutta} | Lagrange | Legendre | Monomial ]\n');
  fprintf('         CheckJac: [ {0} | 1 ]\n');
  fprintf('           Colpts: [ {equidistant} | gauss ]\n');
  fprintf('           Degree: [ integer 1-8 {4} ]\n');  
  fprintf('     DegreeSelect: [ {auto} | manual]\n');
  fprintf('          Display: [ 0 | {1} ]\n');
  fprintf('      fVectorized: [ {0} | 1 ]\n');
  fprintf('   IntMaxMinRatio: [ positive scalar {10} ]\n');
  fprintf('    JacVectorized: [ {0} | 1 ]\n');
  fprintf('       MaxMeshPts: [ integer {10000}]\n');
  fprintf('        OutputFcn: [ string ]\n');
  fprintf('        OutputSel: [ vector of integers ]\n');
  fprintf('      OutputTrace: [ 0 | {1} ]\n');
  fprintf('           RelTol: [ nonnegative scalar {1e-3} ]\n');
  fprintf('         ZfMethod: [ {Newton} | FSolve ]\n\n');
  
  fprintf('       ZfOpt.Display: [ {off} | final | iter ]\n');
  fprintf('      ZfOpt.Jacobian: [ {on} | off ]\n');
  fprintf('   ZfOpt.MaxFunEvals: [ positive scalar {50} ]\n');
  fprintf('       ZfOpt.MaxIter: [ positive scalar {20} ]\n');
  fprintf('        ZfOpt.TolFun: [ nonnegative scalar {0} ]\n');
  fprintf('          ZfOpt.TolX: [ positive scalar {max(1e-15, RelTol /100)} ]\n');
  fprintf('\n');
  return;
end

% If we pass in a function name then pass return the defaults.
if (nargin==1) & ischar(varargin{1})
   funcname = lower(varargin{1});  
   if ~exist(funcname)
      msg = sprintf(...
         'No default options available: the function ''%s'' does not exist on the path.',funcname);
      error(msg)
   end
   try 
      options = feval(funcname,'defaults');
   catch
      msg = sprintf(...
         'No default options available for the function ''%s''.',funcname);
      error(msg)
   end
   return
end


Names = [
    'AbsTol        '
    'Basis         '
    'CheckJac      '
    'ColPts        '
    'DegreeSelect  '
    'Degree        '
    'Display       '
    'fVectorized   '
    'IntMaxMinRatio'
    'JacVectorized '
    'MaxMeshPts    '
    'OutputFcn     '
    'OutputSel     '
    'OutputTrace   '
    'RelTol        '
    'ZfMethod      '
    'ZfOpt         '
    ];
[m,n] = size(Names);
names = lower(Names);

% Combine all leading options structures o1, o2, ... in odeset(o1,o2,...).
options = [];
for j = 1:m
  eval(['options.' Names(j,:) '= [];']);
end

i = 1;
while i <= nargin
  arg = varargin{i};
  if isstr(arg)                         % arg is an option name
    break;
  end
  if ~isempty(arg)                      % [] is a valid options argument
    if ~isa(arg,'struct')
      error(sprintf(['Expected argument %d to be a string property name ' ...
                     'or an options structure\ncreated with ODESET.'], i));
    end
    for j = 1:m
      if any(strcmp(fieldnames(arg),deblank(Names(j,:))))
        eval(['val = arg.' Names(j,:) ';']);
      else
        val = [];
      end
      if ~isempty(val)
        eval(['options.' Names(j,:) '= val;']);
      end
    end
  end
  i = i + 1;
end

% A finite state machine to parse name-value pairs.
if rem(nargin-i+1,2) ~= 0
  error('Arguments must occur in name-value pairs.');
end
expectval = 0;                          % start expecting a name, not a value
while i <= nargin
  arg = varargin{i};
    
  if ~expectval
    if ~isstr(arg)
      error(sprintf('Expected argument %d to be a string property name.', i));
    end
    
    lowArg = lower(arg);
    j = strmatch(lowArg,names);
    if isempty(j)                       % if no matches
      error(sprintf('Unrecognized property name ''%s''.', arg));
    elseif length(j) > 1                % if more than one match
      % Check for any exact matches (in case any names are subsets of others)
      k = strmatch(lowArg,names,'exact');
      if length(k) == 1
        j = k;
      else
        msg = sprintf('Ambiguous property name ''%s'' ', arg);
        msg = [msg '(' deblank(Names(j(1),:))];
        for k = j(2:length(j))'
          msg = [msg ', ' deblank(Names(k,:))];
        end
        msg = sprintf('%s).', msg);
        error(msg);
      end
    end
    expectval = 1;                      % we expect a value next
    
  else
    eval(['options.' Names(j,:) '= arg;']);
    expectval = 0;
      
  end
  i = i + 1;
end

if expectval
  error(sprintf('Expected value for property ''%s''.', arg));
end
