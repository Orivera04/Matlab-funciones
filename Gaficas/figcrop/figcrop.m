function varargout = figcrop(varargin)
%function varargout = figcrop(varargin)          
%                                                     jdc  20-feb-03
%PURPOSE:
%   FIGCROP crops a surface image (e.g. generated by SURF or MESH) to a specified 
%   rectangle. Alternately displays the input image and waits for you to specify 
%   the crop rectangle with the mouse, or crops to an input-defined rectangle.
%   Requires GETRECT.M (in Images toolbox)
%INPUT:
%   FigCrop - operates on current surface object in current figure
%   Figcrop(matrix) - operates on a specified matrix
%   Figcrop(matrix,map) - operates on a matrix with a specified colormap
%   Figcrop(matrix,rectangle) - operates on a matrix with specified crop rectangle
%   Figcrop(matrix,colormap,rectangle) - matrix with specified colormap & rectangle
%
%   Figcrop(handle) - operates on object specified by handle 
%                     (handle can be to a figure, axes, or surface object)
%   Figcrop(handle,map) - handle with specified colormap
%   Figcrop(handle,rectangle) - ... handle with specified crop rectangle
%   Figcrop(handle,colormap,rectangle) - handle with specified colormap & rectangle
% 
%   Crop rectangle not specified: click & drag left mouse button to define region of 
%                                 interest: use the right mouse button to enforce a 
%                                 square region of interest.
%   Crop rectangle specified: region of interest taken as interior of defined rectangle
% 
%OUTPUT:  
%       [B,RECT] = FIGCROP(...) - output is cropped matrix plus rectangle
%   [X,Y,B,RECT] = FIGCROP(...) - as above, plus Xdata and Ydata from source object
%
%      B - trimmed output matrix
%   RECT - 4-element vector with the form [XMIN YMIN WIDTH HEIGHT], in spatial coordinates.
%      X - Xdata from the input matrix
%      Y - Ydata from the input matrix

%CLASS SUPPORT:
%   The input matrix can be of class uint8, uint16, or double. 
%   The output image B is of the same class as the input image. 
%   RECT is always of class double.
%
%EXAMPLES
% assuming 128x128 matrix PLATHONE in memory,
%#1)        [cropped,rect] = figcrop(plathone);
%#2)        [plathonecropped,rectangle] = figcrop(plathone,[20 30 40 50]);
%
%   See also IMCROP

[x,y,a,cm,rect,msg,saveview] = ParseInputs(varargin{:});
if (~isempty(msg))
    error(msg);
end

[m,n,o] = size(a);
xmin = min(x(:)); ymin = min(y(:));
xmax = max(x(:)); ymax = max(y(:));
% Transform rectangle into row and column indices.
if (m == 1)
    pixelsPerVerticalUnit = 1;
else
    pixelsPerVerticalUnit = (m - 1) / (ymax - ymin);
end
if (n == 1)
    pixelsPerHorizUnit = 1;
else
    pixelsPerHorizUnit = (n - 1) / (xmax - xmin);
end
pixelHeight = rect(4) * pixelsPerVerticalUnit;
pixelWidth = rect(3) * pixelsPerHorizUnit;
r1 = (rect(2) - ymin) * pixelsPerVerticalUnit + 1;
c1 = (rect(1) - xmin) * pixelsPerHorizUnit + 1;
r2 = round(r1 + pixelHeight);
c2 = round(c1 + pixelWidth);
r1 = round(r1);
c1 = round(c1);
% Check for selected rectangle completely outside the image
if ((r1 > m) | (r2 < 1) | (c1 > n) | (c2 < 1))
    b = [];
else
    r1 = max(r1, 1);
    r2 = min(r2, m);
    c1 = max(c1, 1);
    c2 = min(c2, n);
    b = a(r1:r2, c1:c2, :);
end
rect = [round(rect(1:2)) size(b,2) size(b,1)];

switch nargout 
case 0
    if (isempty(b))
        warning('The crop rectangle does not intersect the image');
    end
case 1
    varargout{1} = b;
    
case 2
    varargout{1} = b;
    varargout{2} = rect;
    
case 4
    varargout{1} = x;
    varargout{2} = y;
    varargout{3} = b;
    varargout{4} = rect;

otherwise
    error('Too many output arguments');
end
view(saveview) % restore the view of the input figure
figure;
colormap(cm);   
surf(b);       % plot the cropped version
view(saveview) % using the same view as the input figure
shading interp
set(gcf,'CurrentObject',get(gca,'Children'));
%%%
%%% Subfunction ParseInputs
%%%
function [x,y,a,cm,rect,msg,saveview] = ParseInputs(varargin)

if nargin & size(varargin{1})>1,
   surf(varargin{1},bacolors(varargin{1}));
   view(2);
   shading interp;
end   
x = [];
y = [];
a = [];
flag = 0;
cm = [];
rect = [];
msg = '';
posbox = [];
posfig = get(gcf,'Position');
posax = get(gca,'Position');
xbox = 10;
h = msgbox({'Click & Drag to Select a Rec-';'tangular Region of Interest'});
set(h,'Units','pixels');
posbox = get(h,'Position');
ybox = posfig(2)+(posax(2)+posax(4))*posfig(4)+1;
while isempty(posbox),end
set(h,'Position',[xbox ybox posbox(3:4)],'Color','g');
if nargin & ishandle(varargin{1}),
   switch get(varargin{1},'Type');
      case 'figure'
         varargin{1} = get(gca,'Children'),
      case 'axes'
         varargin{1} = gco;
      case 'surface'
         % ok
      otherwise
         error('First argument must be a matrix, figure handle, axes handle, or surface object handle');
   end
end

switch nargin
case 0
    % Get information from current figure using current colormap
    %FigCrop()
    x = get(gco,'Xdata');
    y = get(gco,'Ydata');
    a = get(gco,'Zdata');
    cm = get(gcf,'colormap');
    [ax el] = view;
    saveview = [ax el];
    view(2);
    rect = getrect(gcf);
    
case 1
    % Get data from input matrix using bacolors colormap, or object handle
    % Figcrop(matrix) Figcrop(handle)
    a = varargin{1};
    if size(a,1)==1,       % a is an object handle
       x = get(a,'Xdata');
       y = get(a,'Ydata');
       a = get(a,'Zdata');
    else
       x = (1:size(a,2));    % a is a matrix, use bacolors colormap
       y = (1:size(a,1));
    end   
    cm = colormap;
    [ax el] = view;
    saveview = [ax el];
    view(2);
    rect = getrect(gcf);
    
case 2
    % Get data from input matrix with map or rectangle, or figure handle with rectangle
    % Figcrop(matrix,map), Figcrop(matrix,rectangle), Figcrop(handle,rectangle)
    a = varargin{1};
    if size(a,1)==1,       % a is an object handle
       x = get(a,'Xdata');
       y = get(a,'Ydata');
       a = get(a,'Zdata');
       if (size(varargin{2},2) == 3), % second input is a colormap   
          cm = varargin{2};
          rect = getrect(gcf);
       else                           % second input is a crop rectangle
          cm = colormap;
          rect = varargin{2};
       end
       [ax el] = view;
       saveview = [ax el];
       view(2);
    else                       
       x = (1:size(a,2));  % a is a matrix
       y = (1:size(a,1));
       [ax el] = view;
       saveview = [ax el];
       if (size(varargin{2},2) == 3), % second input is a colormap   
          cm = varargin{2};
          rect = getrect(gcf);
       else                           % second input is a crop rectangle
          cm = colormap;
          rect = varargin{2};
       end   
    end
    
case 3
    % input handle or matrix, plus colormap plus crop rectangle specified
    % Figcrop(matrix,colormap,rectangle), Figcrop(handle,colormap,rectangle)
    a = varargin{1};
    if size(a,1)==1,       % a is an object handle
       x = get(a,'Xdata');
       y = get(a,'Ydata');
       a = get(a,'Zdata');
    else                     % a is a matrix  
       x = [1 size(a,2)];
       y = [1 size(a,1)];
    end
    cm = varargin{2};    % second input is colormap
    [ax el] = view;
    saveview = [ax el];
    view(2);
    rect = varargin{3};  % third input is a crop rectangle
 
otherwise
    msg = 'Too many input arguments';
    return;
end

zmax = max(a(:));
line([rect(1) rect(1)+rect(3) rect(1)+rect(3) rect(1) rect(1)],...
     [rect(2) rect(2) rect(2)+rect(4) rect(2)+rect(4) rect(2)],...
     zmax*[1 1 1 1 1],'LineWidth',0.5,'Color',[0 1 0])
delete(h)

function m = bacolors(m)
% stub for bacolors.m
colormap(copper); %substute copper for customized bacolors colormap