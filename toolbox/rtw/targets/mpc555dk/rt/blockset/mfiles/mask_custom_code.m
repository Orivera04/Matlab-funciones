function [ dispstr,rtwdata ] = mask_custom_code(unique,key,location,top,middle,bottom)
%MASK_CUSTOM_CODE
%   Generates the rtwdata and display string for the extended custom coder block.
%
% Parameters
%   unique  -   A flag to tell the coder that the code generated by this block
%               will be generated only once per enclosing masked library block
%
%   location -  A string telling the coder whereabouts in the generated code
%               the code will appear
%
%   top      -  code for the top of the location
%   middle   -  code for the middle of the location
%   bottom   -  code for the bottom of the location
%
%%  top,middle and bottom can either be a matrix of strings or a cell array
%%  of strings with each row representing a line.
%
% Returns
%
%   dispstr  -  A string to display on the mask of the block
%   rtwdata  -  A structure suitable to be processed by extended_custcode.tlc
%
% Notes
%   This function will cause an error to be thrown if it determines the custom 
%   coder block has been placed in an incorrent subsystem.

%   Copyright 2001-2002 The MathWorks, Inc.
%   $Revision: 1.7.2.1 $
%   $Date: 2004/04/19 01:29:39 $

rtwdata.TLCFile = 'extended_custcode' ;
rtwdata.Location = location;

if ~isempty(top)
   if iscell(top)
      top = strvcat(top{:});
   end
   rtwdata.Top = n(top)';
end
if ~isempty(middle)
   if iscell(middle)
      middle=strvcat(middle{:});
   end
   rtwdata.Middle = n(middle)';
end
if ~isempty(bottom)
   if iscell(bottom)
      bottom=strvcat(bottom{:});
   end
   rtwdata.Bottom = n(bottom)';
end


block = gcb;

tkn = java.util.StringTokenizer(block,'/');
top_level_system = char(tkn.nextElement);
if strcmp(get_param(top_level_system,'blockdiagramType'),'model')
    % We only need to do the uniqueness test if the
    % block is in a model. If it is in a library then
    % the below test will fail as the referenceblock
    % property may return empty and will most likely
    % return the wrong value
    switch unique
    case 1
      %% Multiple instances of this block
      %% will generate code
      rtwdata.Unique='Multiple';
    case 2
      %% Multiple instances of this block
      %% will generate code only once 
      rtwdata.Unique='Unique';
    case 3
      %% Multiple instance of this block will
      %% generate an error during code generation
      rtwdata.Unique='Singleton';
    otherwise
       error('Unique out of range 1-3');
    end
    rtwdata.Key = key;

    if unique>=2
        p = get_param(gcb,'parent');
        while ~isempty(p) & hasmask(p)~=2
            p = get_param(p,'parent');
        end
        if ~isempty(p)
            rtwdata.ReferenceMask = get_param(p,'referenceblock');
            rtwdata.InstanceMask = p;
            if isempty(rtwdata.ReferenceMask)
                error('To use the unique code generation feature of this block it must be placed in a masked library subsystem');
                
            end
        else
            error('To use the unique code generation feature of this block it must be placed in a masked library subsystem');
        end
    end
else
    rtwdata.ReferenceMask = '';
end

dispstr = strvcat([location, '() { '],  top, '. . .', middle, '. . .', bottom, '}');


switch unique
case 2
    refblock = strrep(rtwdata.ReferenceMask,sprintf('\n'),' ');
    dispstr = strvcat('This code is common to multiple',  ...
        'instances of the enclosing masked',  ...
        'library block ',' ', ...
        refblock , ' ', ...
        ['and the key ''' key '''' ] ,' ', '------------------------------------------------------------------ ',  ...
        dispstr);
case 3
    refblock = strrep(rtwdata.ReferenceMask,sprintf('\n'),' ');
    dispstr = strvcat(...
        'This block will allow the enclosing',  ...
        'masked library block' , ' ' , ...
        refblock , ...
        ['with key ''' , key , '''' ], ' ' , ...
        'to be inserted once only in the' , ...
        'model ' , ' ' , ...
        '------------------------------------------------------------------ ',  ...
        dispstr);
    
    
end


dispstr = n(dispstr)';

function r = n(x)
        % Add newlines to end column
        r = [x , char(sprintf('\n')*ones(size(x,1),1))];
        
function r =  t(x)
        % Add spaces to leading column
        r = [repmat((sprintf('        ')),size(x,1),1), x];
