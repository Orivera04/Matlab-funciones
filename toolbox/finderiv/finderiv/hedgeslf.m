function [PortSens, PortValue, PortHolds] = hedgeslf(Sensitivities, Price, CurrentHolds, FixedInd, ConSet)
%HEDGESLF Allocate a self-financing hedge among a collection of instruments.
%   Finds the reallocation in a portfolio of financial instruments which
%   hedges the portfolio against market moves and which is closest to being
%   self-financing (maintaining constant portfolio value).  By default
%   the first instrument entered is hedged with the other instruments.
%
%   [PortSens, PortValue, PortHolds] = hedgeslf(Sensitivities, Price, ...
%       CurrentHolds, FixedInd, ConSet)
%
%   ... Optional input arguments: FixedInd, ConSet ...
%
%   [PortSens, PortValue, PortHolds] = hedgeslf(Sensitivities, Price, ...
%       CurrentHolds)
% 
% Inputs:
%   Sensitivities - NINST by NSENS matrix of dollar sensitivities of
%                   each instrument. Each row represents a different instrument. 
%                   Each column represents a different sensitivity.  
%   
%   Price         - NINST by 1 vector of instrument unit prices.
%   
%   CurrentHolds  - NINST by 1 vector of contracts allocated in each instrument.
%
% Optional Inputs:
%   FixedInd      - Empty or NFIXED by 1 vector of indices of instruments to hold
%                   fixed. The default is FixedInd = 1; the holdings in the first instrument
%                   will be held fixed.  If NFIXED instruments will not be changed, enter
%                   all their locations in the portfolio in a vector.  If no instruments
%                   are to be held fixed, enter FixedInd = [].
% 
%   ConSet       -  NCONS by NINST matrix of additional conditions on
%                   the portfolio reallocations.  An eligible NINST by 1 vector of
%                   contract holdings, PortHolds, satisfies all the inequalities
%                   A*PortHolds <= b, where A = ConSet(:,1:end-1) and b = ConSet(:,end).
%
% Outputs:
%   PortSens     - NSENS by 1 vector of portfolio dollar sensitivities.  When a
%                  perfect hedge exists, PortSens is zeros. Otherwise the best hedge
%                  possible is chosen.
%   
%   PortValue -    Total portfolio value (scalar).  When a perfectly
%                  self-financing hedge exists, PortValue is equal to the value,
%                  dot(Price, CurrentHolds), of the initial portfolio.
%
%   PortHolds -    NINST by 1 vector of contracts allocated to each
%                  instrument. This is the reallocated portfolio.
%   
% Notes:
%   Constraints PortHolds(FixedInd) = CurrentHolds(FixedInd) are
%   appended to any constraints passed in ConSet.  Pass FixedInd = [] to
%   specify all constraints through ConSet.
%
%   The default constraints generated by PORTCONS are inappropriate, since
%   they require the sum of all holdings to be positive and equal to one.
%
%   Hedgeslf will first try to find the allocations of the portfolio
%   that will make it closest to being self-financing, while reducing 
%   the sensitivities to zero. If no solution is found, it finds the 
%   allocations that will minimize the sensitivities. If the resulting 
%   portfolio is self-financing, PortValue will be equal to the value 
%   of the original portfolio. 
%    
% See also HEDGEOPT, PORTCONS, LSQLIN.
%
%
% Example #1: Perfect Sensitivity unreachable
% Sens = [0.44  0.32; 1.0 0.0]
% Price = [1.2; 1.0]
% W0 = [1; 1]
%    [PortSens, PortValue, PortHolds]= hedgeslf(Sens,Price,W0)
%
% Example #2: Conflicting Constraints
% Sens = [0.44  0.32; 1.0 0.0]
% Price = [1.2; 1.0]
% W0 = [1; 1]
% ConSet = pcalims([2 2]) %lower and upper bounds
%
% If nothing is fixed:
%    [PortSens, PortValue, PortHolds]= hedgeslf(Sens,Price,W0,[],ConSet)
%
% If W0(1) is not greater than 2:
% [PortSens, PortValue, PortHolds]= hedgeslf(Sens,Price,W0,1,ConSet)
%
% Example #3: Impossible constraints
% Sens = [0.44  0.32; 1.0 0.0]
% Price = [1.2; 1.0]
% W0 = [1; 1]
% ConSet = pcalims([2 2],[1 1])
%    [PortSens, PortValue, PortHolds]= hedgeslf(Sens,Price,W0,[],ConSet)

%   Author(s): M. Reyes-Kattar, 11-16-1998
%   Copyright 1998-2003 The MathWorks, Inc.
%   $Revision: 1.11.2.2 $  $Date: 2004/04/06 01:08:32 $

% Check for input errors
if(nargin < 3)
   error('Price, Sensitivities, and CurrentHolds are required arguments');
end

if(nargin < 4)
    FixedInd = 1;
end

if(nargin < 5)
   ConSet = [];
end


% Make sure input arguments are consistent
[r, c] = size(Price);
if((r ~= 1) & (c ~= 1))
	error('Price must be a vector')   
end
Price = Price(:);
NumInst = length(Price);

[r, NumSens] = size(Sensitivities);
if(r ~= NumInst)
   error('Number of rows in Sensitivities must be equal to the number of intruments')
end

if(length(FixedInd(:)) > NumInst)
   error('Number of fixed-weight instruments must be less than the total number of instruments')
end

%--------------------------------------------------------------------------
% User specified constraints from FixedInd and ConSet
% ConA   <= Conb   : from user specified constraint ConSet
% ConAeq == Conbeq : from user specifed FixedInd
%--------------------------------------------------------------------------
% Consider inequality constraints passed in by user
if(~isempty(ConSet))
   ConA = ConSet(:,1:end-1);
   Conb = ConSet(:,end);
else
   ConA = [];
   Conb = [];
end
ConAeq = []; Conbeq = [];

% Fix weight as required in FixedInd
if(~isempty(FixedInd))
   % Set to column
   FixedInd = FixedInd(:);
     
   % Identify variable elements
   IndexVar = 1:NumInst;
   IndexVar(FixedInd) = [];
   
   % Create diagonal matrix and take out rows corresponding to variable instruments
   FixAeq  = eye(NumInst);
   FixAeq(IndexVar, :) = [];
   
   Fixbeq = CurrentHolds(FixedInd);
   
   % Add to previous equality contraints
   ConAeq = [ConAeq; FixAeq]; 
   Conbeq = [Conbeq; Fixbeq];
   
end

%--------------------------------------------------------------------------
% require the portfolio to have neutral sensitivity
AeqSens = Sensitivities';
beqSens = zeros(NumSens, 1);

% Add to user specified equality constraints
Aeq = [ConAeq; AeqSens]; 
beq = [Conbeq; beqSens];
%--------------------------------------------------------------------------

% Set options
% Eventually parse our own messages
LsqOptions = optimset('Display','off','LargeScale', 'off');

% Calculate the value of the portfolio before balancing
V0 = Price' * CurrentHolds;

% Define the objective function as the drift (V1 - V0), where V1
% is the value of the portfolio once balanced
C = Price';
d = V0;

% X=LSQLIN(C,d,A,b,Aeq,beq)
[PortHolds, Resnorm, Residual, ExitFlag] = lsqlin(C, d, ...
    ConA, Conb, Aeq, beq, [], [], CurrentHolds, LsqOptions);

if(ExitFlag < 0)
%if(ExitFlag == -1) Original
   % problem is overconstrained. Try just minimizing the sensitivities
   % with only user specified constraints
   C = Sensitivities';
   d = zeros(NumSens, 1);
   
   [PortHolds, Resnorm, Residual, ExitFlag] = lsqlin(C, d, ...
       ConA, Conb, ConAeq, Conbeq, [], [], CurrentHolds, LsqOptions);
   %if(ExitFlag == -1) original
   if(ExitFlag < 0)
      % User specified constraints were too restrictive
      if isempty(FixedInd)
        % All constraints came from ConSet
        error('Overly restrictive allocation constraints specified in ConSet');
      else
         % Constraints came from both ConSet and FixedInd
         error(['Overly restrictive allocation constraints implied by' ...
               ' ConSet and by fixing the weight of instruments(s): ' ...
               num2str(FixedInd(:)') ])
      end
   end
end

% Find new sensitivities
PortSens = (PortHolds(:)' * Sensitivities)';

% Find new value
PortValue = PortHolds(:)' * Price;


