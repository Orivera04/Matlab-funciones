/*
 * File: CommAPI.h
 *
 * Abstract:
 *   This file is the same as:
 *   CommAPI_DLL.h + SFConnector.h + Packet.h + SFRS232.h, 
 *   except that some #include directives have been removed
 *
 *
 * $Revision: 1.11.4.2 $
 * $Date: 2004/04/19 01:27:20 $
 *
 * Copyright 2001-2003 The MathWorks, Inc.
 */

/* Revised: 7/25/2001
 * by:	    Yang Feng
 * Note:	    Changed as base header files been changed.
 */
/* Revised: 8/29/2001
 * by:	    Yang Feng
 * Note:	    Adding necessary part of ms_bsp.h.
 */

#ifndef COMMAPI_h
#define COMMAPI_h


/* The following ifdef block is the standard way of creating macros which make exporting 
 * from a DLL simpler. All files within this DLL are compiled with the COMMAPI_DLL_EXPORTS
 * symbol defined on the command line. this symbol should not be defined on any project
 * that uses this DLL. This way any other project whose source files include this file see 
 * COMMAPI_DLL_API functions as being imported from a DLL, wheras this DLL sees symbols
 * defined with this macro as being exported.
 */

/*  Switch between NONDLL version and DLL version
 *  Note: For non-DLL projects, need to define COMMAPI_DLL_NODLL as prepocessor
 */
#ifdef COMMAPI_NODLL
#define COMMAPI_DLL_API 
#else
#ifdef COMMAPI_DLL_EXPORTS
#define COMMAPI_DLL_API __declspec(dllexport)
#else
/* COMMAPI_DLL_API defined as NULL on C target code */
#if !defined(__cplusplus)
#define COMMAPI_DLL_API
#else
#define COMMAPI_DLL_API __declspec(dllimport)
#endif  /* !defined(__cplusplus) */
#endif  /* COMMAPI_DLL_EXPORTS */
#endif  /* COMMAPI_NODLL */

/* 
 * Definitions from:
 * <matlabroot>/toolbox/rtw/targets/PowerPC_DK/internal/api/CommAPI/src/SFConnector.h
 * - These will be auto-generated by BAT when completely in place.
 */

#if !defined(SFCONNECTOR_h)
#define SFCONNECTOR_h

#if _MSC_VER > 1000
#pragma once
#endif /* _MSC_VER > 1000 */

/* turn off COMMAPI_DLLAPI definition */
/* #define RS232CPPLIB_NODLL   1 */

#ifdef _MSC_VER
    /*Win32 Platform C++ Code */
    #include <windows.h>
    #include <iostream.h>
#else
    /*PPC 509 Target C Code*/
    #include <stdlib.h>
#endif

/* 
 * Definitions from:
 * <matlabroot>/toolbox/rtw/targets/PowerPC_DK/internal/api/CommAPI/src/SFConnector.h
 * - These will be auto-generated by BAT when completely in place.
 */

/* GLOBAL DEFINES */

/*
   Write request types
*/
#define WRITE_CHAR          0x01
#define WRITE_FILE          0x02
#define WRITE_FILESTART     0x03
#define WRITE_FILEEND       0x04
#define WRITE_ABORT         0x05
#define WRITE_BLOCK         0x06
/* ascii definitions*/
#define ASCII_BEL       0x07
#define ASCII_BS        0x08
#define ASCII_LF        0x0A
#define ASCII_CR        0x0D
#define ASCII_XON       0x11
#define ASCII_XOFF      0x13

#ifdef _MSC_VER
#else
    /* PPC 509 Target C Code */
    #define     bool int
    #ifndef false
      #define false       0
    #endif
    #ifndef true
      #define true        1
    #endif
    #define HANDLE      (void *)
    #define BOOL        bool
    #define DWORD       unsigned long
    #define     LPSTR   (char *)
#endif

/*
   GLOBAL VARIABLES
*/

/*
 * Prototypes of functions called between source files
 *
 * HANDLE GetCommPort(const char *);
 * BOOL UpdateConnection(DWORD, BYTE, BYTE, BYTE, DWORD, DWORD);
 * BOOL UpdateCommTimeOuts(DWORD, DWORD, DWORD, DWORD, DWORD);
 * DWORD SendString(LPSTR);
 * DWORD GetString(DWORD, LPSTR);
 * BOOL CloseConnection(void);
 */

/* used to convert unsigned long to string
 * in some machine, it's possible that unsigned long exceeds 4 bytes, in this case,
 * we will truncate it to fit into 4 byte slot (consider big endian/little endian);
 * so from processor viewpoint, the SerialNumber & size are unsigned long, from
 * communication viewpoint, they are fixed 4 bytes data;
 */
typedef union UL2String_tag
{
    unsigned long ULong;
    char ULString[sizeof(unsigned long)];
} UL2String;

/* help determine endian format of the running processor */
typedef union Char2Integer_tag
{
    int IntegerMember;
    char CharMember[sizeof(int)];
} Char2Integer ;

bool ismeLittleEndian(void);

#ifdef __cplusplus
    /* Win32 Platform C++ Code*/
    /* Abstract base class
     * it's the parent of all children classes: RS232, TCPIP...
     * it keep the Packet class seperate from implementation of communication classes
     *
     * Basically, we are using construtor of child classes to pass the required parameter, and use
     * connect() method to connect, disconnect() method to disconnect 
     */
    class COMMAPI_DLL_API SFConnector  
    {
    public:
        bool isLittleEndian;
        bool fConnected;        /*indicate whether it's connected or not (to self machine)*/
        bool fTransmit;         /*indicate whether it has jobs in queue*/
        bool fReceive;          /*indicate whether it's during receiving*/
        char gszPort[20];       /*port name, be "COM1, COM2..." for serial port, be "21..." for TCP/IP*/

        bool fRemoteLittleEndian; /*provided for know whether need byte swapping*/
        bool fRemoteConnected;  /*indicate whether it's connected to other side*/

        bool fAckSwitch;        /*Control whether need to send back ACK packet;*/
        unsigned nRetryTimes;   /*how many times should retry before report failure;*/

		int  errorNo;			/* error number indicate last error happened */
        
    private:
        unsigned long READ_TIMEOUT;             /*read timeout value in ms*/
        unsigned long WRITE_CHECK_TIMEOUT;      /*write timeout in ms*/
        unsigned long STATUS_CHECK_TIMEOUT;     /*status check timeout in ms*/
        
        unsigned long ACK_TIMEOUT;              /*acknowledge message timeout in ms */

        unsigned int SEND_SERIAL_NUMBER;        /*how many packets have been sent from this connector*/
        unsigned int RECEIVE_SERIAL_NUMBER;     /*how many packets have been RECEIVED by this connector*/

    public:
        SFConnector();
        virtual ~SFConnector();

        /*operate counters*/
        unsigned int getSEND_SERIAL_NUMBER(void) { return SEND_SERIAL_NUMBER;};
        unsigned int getRECEIVE_SERIAL_NUMBER(void) { return RECEIVE_SERIAL_NUMBER;};
        unsigned int incSEND_SERIAL_NUMBER(void) { return ++SEND_SERIAL_NUMBER;};
        unsigned int incRECEIVE_SERIAL_NUMBER(void) { return ++RECEIVE_SERIAL_NUMBER;};

        /*pure virtual functions */
        virtual bool Connect(void) = 0; 
        virtual bool Disconnect(void) = 0;

        /*set the value of ACK timeout, return the old ACK timeout value;*/
        virtual unsigned long SetACKTimeOut(unsigned long) = 0;


        /* pure virtual send/receive  c style string
         * note: the char * pointer point the begining of buffer, in fact, it's not 
         *              required to be c style string, bcuz the ulong parameter indicates the length of
         *              buffer;
         *              it's the base of all other send...() functions 
         */
        virtual unsigned long SendCString(char *, unsigned long) = 0;
        /* note:        the function needs to be passed c style string, as we are using strlen() to calculate
         *              string length; */
        virtual unsigned long SendCString(char *); /*refer above function */
        /* pure virtual function to receive string, same as SendCSString() 
         * note:        it's the base of all other receive...() functions */
        virtual unsigned long ReceiveCString(char *, unsigned long) = 0;

        /*virtual send/receive raw char */
        virtual unsigned long SendCharRaw(char);
        virtual unsigned long ReceiveCharRaw(char &);

        virtual unsigned long SendUlong(unsigned long);
        virtual unsigned long ReceiveUlong(unsigned long &);

        /* pure virtual send/receive fixed number of raw data, regardless of eol/eof
         * virtual unsigned long SendRawString(char *, unsigned long) = 0;
         * virtual unsigned long ReceiveRawString(char *, unsigned long) = 0; */

	void SetError(int error) { errorNo = error;}
	int GetError(void) { return errorNo;}
	void ClearError(void) { errorNo = 0;}
	bool ErrorHappened(int checkErrorNo) { return (errorNo==checkErrorNo)?true:false;}
    };

#else  /*!defined(__cplusplus)*/

    /*PPC 509 Target C Code*/
    typedef struct SFConnector  
    {
        bool isLittleEndian;
        bool fConnected;        /*indicate whether it's connected or not*/
        bool fTransmit; /*indicate whether it has jobs in queue*/
        bool fReceive;  /*indicate whether it's during receiving*/
        char gszPort[20];       /*port name, be "COM1, COM2..." for serial port, be "21..." for TCP/IP*/

        bool fRemoteLittleEndian; /*provided for know whether need byte swapping*/
        bool fRemoteConnected;  /*indicate whether it's connected to other side*/

        bool fAckSwitch;        /*Control whether need to send back ACK packet;*/
        unsigned nRetryTimes;   /*how many times should retry before report failure;*/
        
	int  errorNo;			/* error number indicate last error happened */
        
	unsigned int  CommMode; /* An arbitrary value presently 0=host; non-zero=target */

        unsigned long READ_TIMEOUT;     /*read timeout value in ms*/
        unsigned long WRITE_CHECK_TIMEOUT;      /*write timeout in ms*/
        unsigned long STATUS_CHECK_TIMEOUT;     /*status check timeout in ms*/
        unsigned long ACK_TIMEOUT;      /*acknowledge message timeout in ms*/

        unsigned int SEND_SERIAL_NUMBER;        /*how many packets have been sent from this connector*/
        unsigned int RECEIVE_SERIAL_NUMBER;     /*how many packets have been RECEIVED by this connector*/
	char *SFConnectorType;
    } SFConnector;

    /*SFConnector() constructor/destructor C cousin*/
    SFConnector *CreateSFConnector(void);
    void DestroySFConnector(SFConnector *);

    /*see their cousin before*/
    unsigned int getSEND_SERIAL_NUMBER(SFConnector *);
    unsigned int getRECEIVE_SERIAL_NUMBER(SFConnector *);
    unsigned int incSEND_SERIAL_NUMBER(SFConnector *);
    unsigned int incRECEIVE_SERIAL_NUMBER(SFConnector *);

    /*see their cousin before*/
    bool Connect(SFConnector *);        
    bool Disconnect(SFConnector *);

    unsigned long SetACKTimeOut(SFConnector *, unsigned long);

    /*send/receive  c style string
    //note: see their cousin before*/
    unsigned long SFConnectorSendCString(SFConnector *, char *, unsigned long);
    /*note: see their cousin before*/
    unsigned long SFConnectorSendCString2(SFConnector *, char *); /*refer above function/*
    /*note: see their cousin before*/
    unsigned long SFConnectorReceiveCString(SFConnector *, char *, unsigned long);
    /*see their cousin before*/
    unsigned long SFConnectorSendCharRaw(SFConnector *, char);
    unsigned long SFConnectorReceiveCharRaw(SFConnector *, char *);
    unsigned long SFConnectorSendUlong(SFConnector *, unsigned long);
    unsigned long SFConnectorReceiveUlong(SFConnector *, unsigned long *);

#endif /*!defined(__cplusplus)*/


/* global pointer to access Connector objects
 * SFConnector *ptrConnector; */

#endif /* !defined(SFCONNECTOR_h)*/



/* 
 * Definitions from:
 * <matlabroot>/toolbox/rtw/targets/PowerPC_DK/internal/api/CommAPI/src/Packet.h
 * - These will be auto-generated by BAT when completely in place.
 */

#if !defined(PACKET_h)
#define PACKET_h

#if _MSC_VER > 1000
#pragma once
#endif /* _MSC_VER > 1000 */

/*including files section*/
#ifdef __cplusplus
    /*Win32 Platform C++ Code (for DLL only) */
    /*#include "RS232CPPLIB.h"
        renamed to CommAPI_DLL.h to avoid confusing*/
    /* #include "CommAPI_DLL.h" not necessary in CommAPI.h */
#else
#endif

/* #include "SFConnector.h"   not necessary here*/ 


#define MAX_PACKET_SIZE 1024

#define HEAD_SIZE	2
#define	PACKET_TYPE_SIZE	1
#define SERIAL_SIZE	4		/*fix size, don't use sizeof, bcuz it differs between processor*/
#define SIZE_SIZE	4
#define	CRC_SIZE	2
#define TAIL_SIZE	2

/*PACKET TYPE definition*/
#define	hand_shaking	0x00
#define	u_single	0x01
#define	y_single	0x02
#define	c_terminate	0x03
#define announce_packet	0x06	    /* synchronize with pil_comm_api.h*/
#define	ackn_packet	0x05			/* coordinate with pil_comm_api.h */
#define packet_empty	0xff

/*PACKET HEAD, TAIL definiton*/
#define packet_head ((char)0x7e)	    /* Conform to HDLC Framing standard*/
#define packet_tail ((char)0x03)	    /* Conform to HDLC Framing standard*/
#define escape_character  ((char)0x7d)	    /* Conform to HDLC Framing standard*/
#define xon_character	((char)0x13)	    /* Conform to HDLC Framing standard*/
#define xoff_character	((char)0x11)	    /* Conform to HDLC Framing standard*/
#define mask_character	((char)0x20)	    /* Conform to HDLC Framing standard*/

/*enum to be used by ShowCommStatus() function */
enum CommStatus {
    csWaitConnect, 
    csTryConnect,
    csConnectSuccess,
    csConnectFailure,
    csCloseShow
};

/*Function Prtotype used to display communcation status; */
void ShowCommStatus(enum CommStatus csID);

/*enum to be used by ShowCommStatus() function */
enum SFPacketState {
    SFP_NoPacket, 
    SFP_InHead,
    SFP_InType,
    SFP_InSerial,
    SFP_InSize,
    SFP_InPayload,
    SFP_InCRC,
    SFP_InTail,
    SFP_Complete
};

#ifdef __cplusplus
    /* Win32 Platform C++ Code
     * definiton of packet structure, for compatiablity purpose of C code */
struct SFPacket
{
    char head[HEAD_SIZE];			/* head bytes			2 bytes*/
    char PacketType;				/* type of the packet	1 byte*/
	
    /* in some machine, it's possible that unsigned long exceeds 4 bytes, in this case,
     * we will truncate it to fit into 4 byte slot (consider big endian/little endian);
     * so from processor viewpoint, the SerialNumber & size are unsigned long, from
     *  communication viewpoint, they are fixed 4 bytes data;
     */
    unsigned long SerialNumber;		/* serial number		4 bytes */
    unsigned long size;			/* size of packet contents	4 bytes */
    char *ptrContents;				/* pointer to the begin of contents C style string*/
    char CRC[CRC_SIZE];				/* CRC code of packet	2 bytes*/
    char tail[TAIL_SIZE];			/*tail bytes			2 bytes*/
    SFPacketState state;
    char *cursor;
    unsigned int DataCount;
    bool     inQuote;
};
#else
/* Power PC 509 Target C Code*/
typedef struct SFPacket
{
    char head[HEAD_SIZE];			/*head bytes			2 bytes*/
    char PacketType;				/*type of the packet	1 byte*/
    unsigned long SerialNumber;		        /*serial number			4 bytes*/
    unsigned long size;			        /*size of packet contents 4 bytes*/
    char *ptrContents;				/*pointer to the begin of contents C style string*/
    char CRC[CRC_SIZE];				/*CRC code of packet	2 bytes*/
    char tail[TAIL_SIZE];			/*tail bytes			2 bytes*/
    int state;
    char *cursor;
    unsigned int DataCount;
    bool     inQuote;
} SFPacket;
#endif


#ifdef __cplusplus
/* Win32 Platform C++ Code*/
/* Packet Class, knowhow to assemble/disassemble/send/receive itself*/
class COMMAPI_DLL_API CPacket  
{
 public:
    SFPacket packet; 
 public:
    CPacket(SFConnector *, char *);
    CPacket(SFConnector *, char *, unsigned long, char);
    /* CPacket(SFConnector *, char, unsigned long);*/
    virtual ~CPacket();

    /* function to sent itself*/
    bool Send(SFConnector *);
    /* function to get itself*/
    bool Get(SFConnector *);
};
#else
/*PPC 509 Target C Code*/
/*Packet Class, knowhow to assemble/disassemble/send/receive itself*/
typedef struct CPacket  
{
    SFPacket packet; 
} CPacket;
CPacket*    CreateCPacket2(SFConnector *, char *);
CPacket*    CreateCPacket(SFConnector *, char *, unsigned long, char);
void        DestroyCPacket(CPacket *);
        
    /*function to sent itself*/
bool        SendCPacket(CPacket *, SFConnector *);
/*function to get itself*/
bool GetCPacket(CPacket *, SFConnector *);
#endif

#ifdef __cplusplus
    /* Win32 Platform C++ Code */
    /* actually its responsibility is to provide user interface and holds buffers*/
    struct COMMAPI_DLL_API MemoryPacket
    {
	char type;
	unsigned long SerialNumber;
	unsigned long size;
	char *cursor;
	char Buffer[MAX_PACKET_SIZE*10];		/* big buffer for jointed packets*/
    public:
	MemoryPacket(void)	{ type = (char)packet_empty;	size = 0ul; SerialNumber = 0ul;}
	/* first, user call GetBuffer to setup contents size&type, and the start address of 
	 *	buffer will be returned;
	 */
	char *GetBuffer(unsigned long, char);
	/* second, after user fill the buffer, user could call Send() to send the packets*/
	bool Send(SFConnector *);
	/* when user expect to receive packet, user could call Get() to get until get whole packet*/
	bool Get(SFConnector *);
	
    };						
#else
    /*PPC 509 Target C Code*/
    /*actually its responsibility is to provide user interface and holds buffers*/
    typedef struct COMMAPI_DLL_API MemoryPacket
    {
        char type;
        unsigned long SerialNumber;
        unsigned long size;
        char *cursor;
        char Buffer[MAX_PACKET_SIZE*10];                /*big buffer for jointed packets*/
    } MemoryPacket;                                             

    MemoryPacket*       CreateMemoryPacket(void);

    /*first, user call GetBuffer to setup contents size&type, and the start address of 
    //  buffer will be returned;*/
    char *MemoryPacketGetBuffer(MemoryPacket *, unsigned long, char);
    /*second, after user fill the buffer, user could call Send() to send the packets*/
    bool MemoryPacketSend(MemoryPacket *, SFConnector *);
    /*when user expect to receive packet, user could call Get() to get until get whole packet*/
    bool MemoryPacketGet(MemoryPacket *, SFConnector *);

#endif


/*public functions to be used by both host and target platform*/
    /* Send Announce packet out;*/
    bool Announce(SFConnector *ptrConnector);
    /* Waitting for Announce packet;*/
    bool WaitAnnounce(MemoryPacket *InBuffer, SFConnector *ptrConnector);
    /* Sending Acknowledge Packet*/
    bool SendAckPacket(SFConnector *ptrConnector, unsigned long ulSerialNumber);

    /*Used by Master machine for building connection;*/
    bool TryConnect(MemoryPacket *InBuffer, SFConnector *ptrConnector);
    /*Used by Slave machine for waiting connection;*/
    bool WaitConnect(MemoryPacket *InBuffer, SFConnector *ptrConnector);

    
    /* Translate unsigned long value into string based on endianess and (optional) escape sequence */
    unsigned long Ulong2String(char *dest, unsigned long ulValue, bool endianess, bool doFilter);

    /* Translate unsigned long value into string based on endianess*/
    unsigned long String2Ulong(char *source, bool endianess);

    /* Detect whether the character belong to the escape sequence, Yes return true*/
    bool DetectEscapeSequence(char c);

    /*Filter the outgoing message to trasnslate any bytes conflict with packet head/tail/escape character;*/
    unsigned long Filter(char *destination, char *source, unsigned long ulBytes);


#endif /* !defined(PACKET_h)*/


typedef enum CommError_tag
{
	errorNoError = 0,
	errorNoRxData,
	errorNoTxData,
	errorNoConnection,
	errorNoUserAbort
} CommErrorEnum;

    int GetError(SFConnector *ptrConnector);


/* 
 * Definitions from:
 * <matlabroot>/toolbox/rtw/targets/PowerPC_DK/internal/BSPs/win32/CommAPI/src/SFRS232.h
 * - These will be auto-generated by BAT when completely in place.
 */

#if !defined(SFRS232_H)
#define SFRS232_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/* #include "CommAPI_DLL.h"
#include "SFConnector.h" */

#ifdef __cplusplus
class COMMAPI_DLL_API SFRS232 : public SFConnector  
{
private:
        DCB             dcb;                    /* device control block for RS232 port*/
        DCB             dcborig;                /* original DCB value*/
        DWORD   dwInBufferSize; /* input size buffer for intialize serial port*/
        DWORD   dwOutBufferSize;/* output buffer size for initialize serial port*/
        HANDLE  hCommPort;              /* handle for the serila port*/
    COMMTIMEOUTS timeoutsorig;/* original time out settings*/
    COMMTIMEOUTS timeoutsnew; /* new time out settings*/

public:
        /* Note: it does nothing, only used to pass parameters*/
        SFRS232(const char *, DWORD, BYTE, BYTE, BYTE, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
        virtual ~SFRS232();

        /* vitrual function inhereited from SFconnector class*/
        virtual bool Connect(void);     
        virtual bool Disconnect(void);
        virtual unsigned long SendCString(char *, unsigned long);
        virtual unsigned long ReceiveCString(char *, unsigned long);

        virtual unsigned long SetACKTimeOut(unsigned long uiTimeOut);

        /* internal function to get control of comm port*/
        HANDLE GetCommPort(void);
};

#endif /* defined __cplusplus*/

#endif /* !defined(SFRS232_H)*/


/* 
 * Definitions from:
 * <matlabroot>/toolbox/rtw/targets/PowerPC_DK/internal/BSPs/include/mw_bsp.h
 * - These will be auto-generated by BAT when completely in place.
 */
#ifndef MW_BSP_H
#define MW_BSP_H
/* code for C platform only*/
#ifndef __cplusplus

#ifndef WIN32

/* 
 * Note:	To use following timer routines, caller program need declare a local
 *			time stamp of type "unsigned long long"
 */
 
/* start timer */
bool start_timer(unsigned long long *ullPtr);

/* return time in ms */
unsigned long read_timer(unsigned long long *ullPtr);

/* stop timer */
bool stop_timer(unsigned long long *ullPtr);

/* sleep for specified ms */
void sleep(unsigned long time_in_ms);

#endif /* _WIN32_WINNT */
#endif	/* __cplusplus*/
#endif  /* MW_BSP_H */ 


///////////////////////////////////////////////////////////////////////////////
#endif /* !defined(COMMAPI_h) */
