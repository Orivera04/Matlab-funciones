function [tau,y,tcol,ycol,err_norm] = sbvp(bvpfile,tau0,y0,bvpopt,varargin);
%   SBVP 1.0 (Rel. 1/2003) Solve singular boundary value problem for first order ODEs (adaptive mesh)
%
%   [TAU,Y,TCOL,YCOL,ERR_NORM] = SBVP(BVPFILE[,TAU0,Y0,BVPOPT,PARAM1,PARAM2,...])
%   determines a suitable mesh TAU on which the boundary value problem
%
%      y' = f(t,y) , t \in (a,b) , R(y(a),y(b))=0
%
%   is solved by the method of collocation. The right hand side f(t,y) may contain
%   a singularity of the form 
%
%      f(t,y) =  1/(t-a) * M(t) + g(t,y),
%
%   where M is a matrix which depends continuously on t and g is a smooth function.
%   The mesh is chosen such that the estimated error e(t) of the solution approximation 
%   satisfies 
%      max_t (|e(t)| / (AbsTol + |y(t)| * RelTol)) < 1.
%   Values for AbsTol and RelTol are provided in the options structure BVPOPT.
%
%   INPUT ARGUMENTS:
%
%   BVPFILE is the function handle or name of an m-file that defines the 
%    function f, the boundary conditions and some Jacobians (for details see
%    the BVPFILEPattern at the end of this text). 
%    SBVP automatically detects whether the BVP is linear. In this case, the 
%    BVPFILE can (but need not) be coded such that it returns the inhomogenities 
%    of the differential equation and the boundary conditions only.
%   
%   [TAU0 is a strictly monotonous sequence that defines the initial mesh.
%    TAU0 should be a row vector. If TAU0 is empty or not specified, SBVP 
%    evaluates BVPFILE('tau') to obtain it. 
%    If TAU0 consists of the beginning and end of the integration interval only,
%    SBVP automatically selects a suitable initial mesh on that integration interval.]
%
%   [Y0 is an initial approximation of the solution of the BVP and should be a 
%    (dim x length(TAU0))-matrix, where dim is the dimension of the system
%    to be solved. If Y0 is empty or not specified, SBVP evaluates BVPFILE('y0',TAU0) 
%    to obtain it and uses the default initial approximation (all zeros) if this fails.
%    For linear problems, no initial approximation is necessary.]
%
%   [BVPOPT is a parameter struct that determines the tolerances, the collocation 
%    point distribution, etc. BVPOPT should be generated by SBVPSET (see SBVPSET 
%    for details). If BVPOPT is empty or not specified, SBVP evaluates BVPFILE('bvpopt') 
%    to obtain it and uses the default options if this fails.]
%
%   [PARAM1,PARAM2 are parameters of the boundary value problem that are passed on 
%    to BVPFILE. See the BVPFILE Pattern below.]
%
%
%   OUTPUT ARGUMENTS:
%
%   TAU is the final mesh produced by SBVP.
%
%   Y is the final approximation of the solution on the mesh TAU.
% 
%   TCOL is the final collocation grid. The collocation grid contains mesh points
%    and collocation points and is thus finer than TAU.
%
%   YCOL is the final approximation of the solution on TCOL.
%
%   ERR_NORM is the norm of the last error estimate given on TCOL
%
%
%   BVPFILE Pattern:
%
%   function out=BVPFilePattern(flag,t,y,ya,yb,param1,param2,...)
%
%   switch flag
%   case 'f'       % rhs of the differential equation
%     out=<insert f(t,y) here>;
%   case 'df/dy'   % Jacobian of the rhs
%     out=<insert df/dy(t,y) here>;
%   case 'R'       % boundary condition
%     out=<R(ya,yb)>;
%   case 'dR/dya'  % Jacobian of the boundary condition w.r.t. ya
%     out=<dR/dya(ya,yb)>;
%   case 'dR/dyb'  % Jacobian of the boundary condition w.r.t. yb
%     out=<dR/dyb(ya,yb)>;
%   case 'tau'  (optional)
%     out=<initial mesh>;
%   case 'y0' (optional)
%     out=<initial approximation y0(t)>
%   case 'bvpopt' (optional)
%     out=<solution options for the BVP, see SBVPSET>
%   otherwise
%     error('unknown flag');
%   end
%
%   See also SBVPSET  SBVPCOL  SBVPPLOT  SBVPPHAS2  SBVPPHAS3  FUNCTION_HANDLE

%   Copyright (c) 2003 Winfried Auzinger 
%                      Guenter Kneisl
%                      Othmar Koch
%                      Ewa Weinmueller
%                      Vienna University of Technology


%################################################################################
%##################################### MAIN #####################################
%################################################################################


% ********* generate default options
default_zf_opt = optimset(...
      'Display','off',...
      'TolFun',0,...
      'TolX',[],...
      'MaxIter',20,...
      'MaxFunEvals',50,...
      'Jacobian','on');

defaultopt = sbvpset(...
      'AbsTol',1e-6,...
      'Basis','RungeKutta',...
      'CheckJac',0,...
      'ColPts','Equidistant',...
      'Degree',4,...      
      'DegreeSelect','auto',...
      'Display',1,...
      'fVectorized',0,...
      'IntMaxMinRatio',10,...
      'JacVectorized',0,...
      'MaxMeshPts',10000,...
      'OutputFcn','',...
      'OutputSel',[],...
      'OutputTrace',1,...
      'RelTol',1e-3,...
      'ZfMethod','Newton',...
      'ZfOpt',default_zf_opt);
   
% ********* return default options if required
if nargin==1 & nargout <= 1 & isequal(bvpfile,'defaults')
   tau = defaultopt;
   return
end




% ********* parameters for the bvpfile
parameters = varargin;

% ********* determine if an argument-check is necessary or has been done by a previous instance of SBVP
try
   argcheck = bvpopt.Private.Argcheck;
catch
   argcheck = 1;
end


% ###############################################################################
% ############################# ARGUMENT CHECK ##################################
% ###############################################################################


if argcheck
   
   
%********************************************************************************
%************************ CHECK ARGUMENT AVAILABILITY ***************************
%********************************************************************************
   
   
error(nargchk(1,Inf,nargin));

if isstr(bvpfile) 
   if exist(bvpfile)
      bvpfile = eval(['@' bvpfile]);
   else
      error(['The bvpfile does not exist on the search path.']);
   end
elseif ~exist(func2str(bvpfile))
   error(['The bvpfile does not exist on the search path.']);
end


% ********** handle the cases in which not all arguments are passed
switch nargin  
case 1  
   try
      tau0=feval(bvpfile,'tau');
   catch
      error([' The mesh TAU0 must be specified in the bvpfile or passed as argument !']);      
   end
         
   try
      bvpopt = feval(bvpfile,'bvpopt');
   catch
      bvpopt = sbvpset;
      fprintf(' BVPOPT unspecified or incorrect - Using default options\n');
   end
   
case {2,3}   
   try
      bvpopt = feval(bvpfile,'bvpopt');
   catch
      bvpopt = sbvpset;
      fprintf(' BVPOPT unspecified or incorrect - Using default options\n');      
   end
end


% ********** handle the cases in which some arguments are empty
if isempty(tau0)
   try
      tau0=feval(bvpfile,'tau');
   catch
      error([' The mesh TAU0 must be specified in the bvpfile or passed as argument !']);
   end
end

if isempty(bvpopt)
   try
      bvpopt = feval(bvpfile,'bvpopt');
   catch
      bvpopt = sbvpset;
      fprintf(' BVPOPT unspecified or incorrect - Using default options\n');      
   end
end

% ********** Now build the final options structure

bvpopt.ZfOpt = optimset(defaultopt.ZfOpt,bvpopt.ZfOpt);
bvpopt = sbvpset(defaultopt, bvpopt);

if bvpopt.RelTol < 1e-15
   fprintf('\n WARNING: A RelTol of %.2e makes little sense as the \n machine accuracy is %.2e\n\n',bvpopt.RelTol,eps);
end

if ~isempty(bvpopt.ZfOpt) & bvpopt.ZfOpt.TolX < 1e-15
   fprintf('\n WARNING A TolX of %.2e makes little sense as the \n machine accuracy is %.2e\n\n',bvpopt.RelTol,eps);
end

% ***** Define the default value for TolX, the zerofinder tolerance
if isempty(bvpopt.ZfOpt.TolX)
   bvpopt.ZfOpt.TolX = max(1e-15, bvpopt.RelTol / 100);
end


% ***** Determine whether boundary conditions and differential equation are linear
try
   dRdya = feval(bvpfile,'dR/dya',{},{},{},{},parameters{:});
   dRdyb = feval(bvpfile,'dR/dyb',{},{},{},{},parameters{:});
   
   if isnumeric(dRdya) & isnumeric(dRdyb)
      bvpopt.Private.BClinear = 1;
   else
      bvpopt.Private.BClinear = 0;
   end   
catch
   bvpopt.Private.BClinear = 0;
end         

if bvpopt.Private.BClinear % if BC are nonlinear, the whole problem is nonlinear
   try 
      J = feval(bvpfile,'df/dy',(tau0(1)+tau0(end))/2,{},{},{},parameters{:});
      if isnumeric(J)
         bvpopt.Private.IsLinear = 1;
      else
         bvpopt.Private.IsLinear = 0;
      end
   catch
      bvpopt.Private.IsLinear = 0;
   end
else
   bvpopt.Private.IsLinear = 0;
end



bvpopt.Private.DefaultInitialApproximation = 0;

% ********** an initial approximation is necessary for nonlinear f
if ~bvpopt.Private.IsLinear   % an initial approximation is necessary
   if ~exist('y0')    % y0 has not been specified as an argument
      try
         y0 = feval(bvpfile,'y0',tau0);
      catch
         y0 = get_default_initial_approximation(bvpfile,tau0,bvpopt,parameters);
         bvpopt.Private.DefaultInitialApproximation = 1;         
      end
   elseif isempty(y0) % y0 has been specified as an argument, but is empty
      try
         y0=feval(bvpfile,'y0',tau0);
      catch
         y0 = get_default_initial_approximation(bvpfile,tau0,bvpopt,parameters);
         bvpopt.Private.DefaultInitialApproximation = 1;         
      end
   end
else
   % ********** In the linear case, y0 will not be used anymore. 
   % ********** It is only defined to avoid special cases   
   y0 = get_default_initial_approximation(bvpfile,tau0,bvpopt,parameters);
   bvpopt.Private.DefaultInitialApproximation = 1;
end

% ***** selected output components
if isempty(bvpopt.OutputSel)   % output all components
   bvpopt.OutputSel = 1:size(y0,1);
end


% *********** Check arguments TAU, Y0, BVPOPT and the BVPFILE 
if isnumeric(bvpopt.ColPts)  % user-defined distribution of collocation points
   p = length(bvpopt.ColPts);
   
   if p > 8
      fprintf(' ERROR! Maximum number of collocation points is 8. \n');
      return
   end
      
   if lower(bvpopt.DegreeSelect(1)) ~= 'm'
      fprintf(' WARNING! ''DegreeSelect'' changed to ''manual'' to match collocation point distribution.\n',p);
      
      bvpopt.DegreeSelect = 'Manual';
   end
      
      
   if bvpopt.Degree ~= p
      fprintf(' WARNING! Collocation degree changed to %i to match collocation point distribution.\n',p);
      
      bvpopt.Degree = p;
   end
   
   if min(bvpopt.ColPts)<= 0 | max(bvpopt.ColPts) >= 1
      error(' Collocation point distribution must be given on the open interval (0,1).');
   end    
elseif ~(isequal(lower(bvpopt.ColPts(1)),'e') | isequal(lower(bvpopt.ColPts(1)),'g'))
   error('Bad value for ColPts property.');  
end

% ***** Use 2 characters to identify the Basis property ('la' -> lagrange, 'le' -> legendre)
if lower(bvpopt.Basis(1))=='m' % monomial
   bvpopt.Basis = 'mo';
elseif lower(bvpopt.Basis(1))=='r' % Runge-Kutta
   bvpopt.Basis = 'ru';
elseif length(bvpopt.Basis) >= 2
   if ~(isequal(lower(bvpopt.Basis(1:2)),'le') | isequal(lower(bvpopt.Basis(1:2)),'la'))
      error('Bad value for Basis property.');  
   end 
else
   error('Bad value for Basis property.');  
end

if ~(isequal(lower(bvpopt.DegreeSelect(1)),'m') | isequal(lower(bvpopt.DegreeSelect(1)),'a'))
   error('Bad value for DegreeSelect property.');  
end 

if bvpopt.Degree > 8
   fprintf(' WARNING! Maximum collocation degree is 8.\n');
   fprintf(' Degree changed to 8 .\n');
   
   bvpopt.Degree = 8;
end

if ~isnumeric(tau0) | ~isnumeric(y0) | size(tau0,2)<2 | size(tau0,1)~=1 | size(tau0,2) ~= size(y0,2)
   error(' TAU0 and Y0 should be 1 x (N+1) and d x (N+1) matrices, respectively, N > 1 !');
end

if min(diff(tau0))<=0
   error(' TAU0 must be a strictly monotonous sequence !');
end

if ~isstruct(bvpopt)
   error(' BVPOPT should be created using the SBVPSET command !');
end

if bvpopt.AbsTol <= 0
   error(' AbsTol must be greater than zero.');
end


check_bvpfile(bvpfile,tau0,y0,bvpopt,parameters);

if bvpopt.CheckJac
   check_bvpfile_jacobians(bvpfile,tau0,y0,bvpopt,parameters);
end

% ********** do not check arguments in sbvpcol, sbvperr, or the next instance of sbvp
bvpopt.Private.Argcheck = 0;

% ********** use preconditioner
bvpopt.Private.Preconditioner = 1;

% ********** define some constants used in the mesh adaption process
bvpopt.Private.SmoothMonitorFunction = 1;
bvpopt.Private.SmoothFactor = 0.05;

% ********** Refine Mesh a little bit more than "asymptotically" necessary
% ********** to make up for error of error estimator etc.
bvpopt.Private.SafetyMargin = 0.1;


end % if argcheck

% ###############################################################################
% ########################### END ARGUMENT CHECK ################################
% ###############################################################################




%********************************************************************************
%************************** DETERMINE INITIAL MESH ******************************
%********************************************************************************

% ********** autodetermine order of collocation
if lower(bvpopt.DegreeSelect(1)) == 'a'  % autodetermine order   
   switch max(1, ceil(-log10(bvpopt.AbsTol)))
   case {1,2}
      p = 2;
   case {3,4}
      p = 4;
   case {5,6,7}
      p = 6;
   otherwise
      p = 8;
   end
         
   bvpopt.Degree = p;
   
   if bvpopt.Display
      fprintf(' Determine collocation degree ... p = %i \n',p);
   end
else
   p = bvpopt.Degree;
end


% ********** determine initial mesh
N = size(tau0,2) - 1;

a = tau0(1);
b = tau0(end);

if N < 5   % only the integration interval is given -> autodetermine suitable mesh tau   
   N = min( max(5 , floor(1/(bvpopt.AbsTol^(1/p)))), 101);
   tau = linspace(a,b,N+1);
   
   if bvpopt.Private.DefaultInitialApproximation
      y0 = zeros(size(y0,1),length(tau));
   else
      y0 = interp1(tau0',y0',tau','*linear')';
   end
   
   if bvpopt.Display
      fprintf(' Determine initial mesh ... N = %i\n',N);      
   end
else
   tau = tau0;
end


%********************************************************************************
%************************ SOLVE BVP, ESTIMATE ERROR *****************************
%********************************************************************************


% ***** initialize output function
if ~isempty(bvpopt.OutputFcn)
   
   h = diff(tau);
   rho = [0:p]' ./ (p+1);
   tcol = ones(p+1,1) * tau(1:N)  +  rho * h ;
   
   tcol = [tcol(:)' tau(end)];
   
   ycol0 = interp1q(tau',y0',tcol')';
   
   feval(bvpopt.OutputFcn,tcol,ycol0(bvpopt.OutputSel,:),bvpopt.Degree,'init');
   
   if bvpopt.OutputTrace
      title('Hit any key to continue');
      pause
      title('');
      drawnow
   end
end


% ***** solve BVP, estimate error
[tau,y,qTol,eTol,err_norm,ycol_norm,tcol,ycol] = ...
   solve_and_estimate_error(bvpfile,tau,y0,bvpopt,parameters);


% ********** check if tolerances are already satisfied
if qTol < 1
   return
end


%********************************************************************************
%********************* GENERATE MESH FOR EQUIDISTRIBUTION ***********************
%********************************************************************************

% ***** if error estimation is unreliable
if  max(err_norm) > max(ycol_norm)
   
   % ***** evaluate rhs at current solution approximation
   if bvpopt.fVectorized
      f = feval(bvpfile,'f',tau(2:end),y(:,2:end));
   else
      f = zeros(size(y,1), N);
      for k=2:N+1
         f(:,k-1) = feval(bvpfile,'f',tau(k),y(:,k));
      end
   end
   
   % ***** f(0,y(0)) may be undefined, so approximate it by finite differencing
   f = [ (y(:,2) - y(:,1))/(tau(2)-tau(1))  f ]; 
   
   % ***** determine new N
   N_new = floor( max(abs(f(:))) / eTol^(1/p) );
   
   % ***** avoid nonsense due to insufficient approximation (2*N < N_new < 5*N)
   N_new = min( max(2*N, N_new) , 5*N);
   
   if bvpopt.Display
      fprintf(' Error estimation unreliable, refine mesh ... N = %i\n',N_new);
   end
   
   % ***** new mesh
   tau_new = linspace(a,b,N_new+1); 
   
   % ***** new solution approximation
   if bvpopt.Private.DefaultInitialApproximation
      y = zeros(size(y,1),length(tau_new));
   else
      y = interp1(tau',y',tau_new','*linear')';
   end
   
   tau = tau_new;
   N = N_new;
   
   % ***** solve BVP, estimate error
   [tau,y,qTol,eTol,err_norm,ycol_norm,tcol,ycol] = ...
      solve_and_estimate_error(bvpfile,tau,y,bvpopt,parameters);
  
  
   % ***** while error estimation is still unreliable   
   while max(err_norm) > max(ycol_norm)
      
      N = floor(3/2 * N);
            
      if N > bvpopt.MaxMeshPts
         fprintf(' \n Maximum Number of mesh points exceeded \n\n');
         return      
      end
      
      if bvpopt.Display
         fprintf(' Error estimation unreliable, refine mesh ... N = %i\n',N);
      end
            
      tau_new = linspace(a,b,N+1);

      % ***** new solution approximation
      if bvpopt.Private.DefaultInitialApproximation
         y = zeros(size(y,1),length(tau_new));
      else
         y = interp1(tau',y',tau_new','*linear')';
      end
   
      tau = tau_new;
     
      % ***** solve BVP, estimate error
      [tau,y,qTol,eTol,err_norm,ycol_norm,tcol,ycol] = ...
         solve_and_estimate_error(bvpfile,tau,y,bvpopt,parameters);

   end
end

% ********** check if tolerances are already satisfied
if qTol < 1
   return
end


   
%********************************************************************************
%********************* EQUIDISTRIBUTION OF THE GLOBAL ERROR *********************
%********************************************************************************

if bvpopt.Display
   fprintf(' Equidistribute global error ...');
end


% ********** generate monitor function theta, see paper
theta = err_norm .^ (1/p);                  % error norm on tau-mesh

% ********** generate smoothed monitor function theta_bar and final mf theta_tilde
if bvpopt.Private.SmoothMonitorFunction
   % ***** smoothing range, see paper
   s = max(2, floor(N * bvpopt.Private.SmoothFactor));
   
   % ***** speed
   two_s1 = 2 * s + 1;
   
   theta_bar = zeros(size(theta));
   for i=1:s+1
      theta_bar(i) = sum(theta(1:s+i)) / (s+i); 
      theta_bar(end-i+1) = sum(theta(end-(s+i)+1:end)) / (s+i); 
   end
   
   for i=s+2:length(theta_bar)-(s+1)
      theta_bar(i) = sum(theta(i-s:i+s)) / two_s1;
   end

   % ***** the equidistribution function
    theta_tilde = max([theta ; theta_bar]);

else % no smoothing of the monitor function
   theta_tilde = theta;
end

global t_
grid_matrix = [tau(1:N) ; t_];
grid = [grid_matrix(:) ; tau(end)]';

% ********** try to equidistribute theta_tilde on a new mesh
rho = 1./ ((length(grid)-1)*diff(grid));
I = cumtrapz(grid, theta_tilde .* [rho rho(end)]);

% ***** determine new number of mesh points new_N
SM = bvpopt.Private.SafetyMargin;
new_N = max(ceil(1.5*N), ceil( N * (1+SM) * I(end) / eTol^(1/p)));


% ***** for robustness and accuracy, generate the new mesh on the inner points
% ***** of the interval [a,b] and add a and b afterwards
lin = linspace(a,b,new_N+1);

new_tau = [a  ( interp1( (a + (b-a)/I(end) * I)' , grid' , lin(2:new_N)','spline') )'  b];

if bvpopt.Display
   fprintf(' N = %i\n',new_N);
   fprintf(' Control hmax to hmin ratio ...');
end


%********************************************************************************
%************************* CONTROL h_max:h_min RATIO ****************************
%********************************************************************************

h = diff(new_tau);
ratio_bound = bvpopt.IntMaxMinRatio;

% ***** all insert_intervals I_k need insert_pts(k) additional pts
[dummy, insert_intervals, nr_of_insert_pts] = find( floor( h/(ratio_bound*min(h))));

% ***** collect all the inserted points in the addpts vector
addpts = [];
if ~isempty(nr_of_insert_pts)
   for l=unique(nr_of_insert_pts)
      point_dist = (1:l)/(l+1);
   
      needs_l_insert_pts = insert_intervals( nr_of_insert_pts == l );
   
      point_matrix = new_tau(needs_l_insert_pts)' * ones(1,l) + ...
                     h(needs_l_insert_pts)' * point_dist;
   
      addpts = [addpts ; point_matrix(:)];
   end
end

% ***** sort all points to obtain the new mesh
if length(addpts)
   new_tau = sort([new_tau addpts']);
end

% ***** interpolate y onto new mesh
if ~bvpopt.Private.IsLinear
   y = interp1q(tau',y',new_tau')';
end

% ***** give proper names
tau = new_tau;
N = size(new_tau,2) - 1;

if N > bvpopt.MaxMeshPts
  fprintf(' \n Maximum Number of mesh points exceeded \n\n');
  return      
end


if bvpopt.Display
   fprintf(' N = %i\n',N);
end


%********************************************************************************
%********************* SOLVE BVP ON EQUIDISTRIBUTED MESH  ***********************
%********************************************************************************


[tau,y,qTol,eTol,err_norm,dummy,tcol,ycol] = ...
   solve_and_estimate_error(bvpfile,tau,y,bvpopt,parameters);

% ***** check if tolerances are already satisfied
if qTol < 1
   return
end


%********************************************************************************
%************************** REFINE MESH COHERENTLY ******************************
%********************************************************************************

% ********** insert additional points into mesh 
insert_ratio = ((N * (max(err_norm) / eTol)^(1/p) ) - 1) / (N-1);

% ***** possible ratios are 1.5 2 3 4 6 8 12, we round to nearest
possible_ratio = [1.5 2 3 4 6 8 12];
round_point = [1.75 2.5 3.5 5 7 10 Inf];

rounded_insert_ratio = possible_ratio( insert_ratio < round_point );

% ***** avoid too large refinement
if rounded_insert_ratio(1) == 12
   rounded_insert_ratio = 1.5;
end

if rounded_insert_ratio(1) == 1.5
   [tau,y] = refine_mesh_2_to_3(tau,y,bvpopt.Private.IsLinear);
else
   [tau,y] = refine_mesh(tau,y,rounded_insert_ratio(1),bvpopt.Private.IsLinear);
end

if bvpopt.Display
   fprintf(' Refine mesh by factor %.1f ... N = %i\n',rounded_insert_ratio(1),length(tau)-1);
end      

%********************************************************************************
%****************************** INSERTION LOOP **********************************
%********************************************************************************

% ***** We will try to reach the tolerances by subsequent mesh point insertion
while length(tau) <= bvpopt.MaxMeshPts
     
   [tau,y,qTol,eTol,err_norm,dummy,tcol,ycol] = ...
      solve_and_estimate_error(bvpfile,tau,y,bvpopt,parameters);

   % ***** check if tolerances are already satisfied
   if qTol < 1
      return
   end
   
   [tau,y] = refine_mesh_2_to_3(tau,y,bvpopt.Private.IsLinear);
   
   if length(tau) <= bvpopt.MaxMeshPts & bvpopt.Display
      fprintf(' Refine mesh by factor 1.5 ... N = %i\n',length(tau)-1);          
   end  
end


%  ********** tolerances have not been reached, exit with a warning
fprintf('\n Maximum number of mesh points has been exceeded without reaching the tolerances!\n\n');









%################################################################################
%################################# SUBROUTINES ##################################
%################################################################################


%********************************************************************************
%********************* SOLVE AND ESTIMATE GLOBAL ERROR **************************
%********************************************************************************


function [tau,y,qTol,eTol,err_norm,ycol_norm,tcol,ycol]=...
             solve_and_estimate_error(bvpfile,tau,y,bvpopt,parameters);
          
if bvpopt.Display
   fprintf(' Solve BVP ...');         
end

% ***** Try if solution of the BVP is possible 
lasterr('');    % initialize error state    
try
   % ***** solve BVP on mesh tau
   tic
   if bvpopt.Private.IsLinear
      [y,tau,ycol,tcol,f_col,fprime_col] = sbvpcol(bvpfile,tau,y,bvpopt,parameters{:});
   
      % ***** in the linear case, the function evaluations made in SBVPCOL (f, f' at the colpts)
      % ***** can be reused in SBVPERR. Additionally, we need f and f' at the mesh tau.
      f_tau = evaluate_f(bvpfile,tau(2:end),bvpopt,parameters);
      fprime_tau = evaluate_fprime(bvpfile,tau(2:end),bvpopt,parameters);
   
      d = size(y,1);
      p = bvpopt.Degree;
      N = length(tau)-1;
   
      % ***** f and f' in the form necessary for SBVPERR
      bvpopt.f = reshape([reshape(f_col,d*p,N) ; f_tau], d, N*(p+1));
      bvpopt.fprime = reshape([reshape(fprime_col,d^2*p,N) ; reshape(fprime_tau,d^2,N)], d, d,N*(p+1));
   
   else
      [y,tau,ycol,tcol] = sbvpcol(bvpfile,tau,y,bvpopt,parameters{:});
   end
   
   if bvpopt.Display & lower(bvpopt.ZfOpt.Display(1)) == 'o'  % off
      fprintf(' %.2f seconds \n',toc)
   end
   
   if bvpopt.Display
      fprintf(' Estimate error ... ');
   end   
   
      
   % ***** estimate error of solution
   tic
   err = sbvperr(bvpfile,tcol,ycol,bvpopt,parameters{:});

   if bvpopt.Display & lower(bvpopt.ZfOpt.Display(1)) == 'o'  % off
      fprintf(' %.2f seconds \n',toc)
   end
   
   % ***** handle output
   stop = 0; % do not stop
   if ~isempty(bvpopt.OutputFcn)
      stop = feval(bvpopt.OutputFcn,tcol,ycol(bvpopt.OutputSel,:),bvpopt.Degree,'');
      if bvpopt.OutputTrace
         title('Hit any key to continue');
         pause
         title('');
         drawnow
      end
   end   
   
   
catch  % an error has occurred in sbvpcol or sbvperr
   msg = lasterr;
   
   if length(findstr(msg,'System matrix is close to singular'))
      
      if length(tau) < bvpopt.MaxMeshPts
         
         % ***** determine whether the boundary conditions are linear         
         if bvpopt.Private.BClinear   % system matrix becomes regular if mesh is sufficiently fine
            
            fprintf('\n System matrix close to singular. Restarting SBVP on a refined mesh. \n\n'); 
            
            if ~isempty(bvpopt.OutputFcn)
               delete(findobj('type','figure','Tag','CurrentOutputFunction'));
            end
                        
            % ***** refine mesh, interpolate y onto refined mesh
            new_tau = linspace(tau(1), tau(end), min(2*length(tau)-1, bvpopt.MaxMeshPts));
            new_y   = interp1q(tau',y',new_tau')';

            % ***** restart SBVP                     
           
            [tau,y,tcol,ycol,err_norm] = feval(mfilename,bvpfile,new_tau,new_y,bvpopt,parameters{:});
            
            % ***** exit this instance of SBVP
            qTol = -1;
            eTol = [];
            ycol_norm = [];
            return
         else                 % nonlinear boundary conditions, the initial approximation can 
                              % be responsible for the singularity
            fprintf('\n System matrix close to singular. Possible reasons : \n'); 
            fprintf(' 1) There is an error in the bvpfile. \n');
            fprintf(' 2) The analytical BVP is not well-posed. \n');
            fprintf(' 3) The initial approximation is unsuitable. \n'); 
            fprintf(' 4) The initial mesh is not fine enough. \n\n'); 
            
            error('System matrix close to singular.');
         end 
                           
                           
      else % length(tau) = MaxMeshPts
         error(' System matrix is close to singular on a mesh with the maximum number of mesh points.');                           
      end                           
      
   else % another error has occurred
      error(msg);
   end
end
   

% ***** get the norms of solution and error
ycol_norm = max(abs(ycol),[],1);
err_norm = max(abs(err),[],1);

% ***** determine the tolerances
[qTol,jmax] = max(err_norm ./ (bvpopt.AbsTol + ycol_norm * bvpopt.RelTol));
 eTol = bvpopt.AbsTol + ycol_norm(jmax) * bvpopt.RelTol;
 
if abs(qTol) < 1
   if bvpopt.Display
      fprintf('\n Tolerances satisfied\n\n');
   end
   
   y = y - err(:,1:bvpopt.Degree+1:end);
   ycol = ycol - err;
   
   % ***** finish graphic output   
   if ~isempty(bvpopt.OutputFcn)    
      feval(bvpopt.OutputFcn,tcol,ycol(bvpopt.OutputSel,:),bvpopt.Degree,'done');
   end
elseif stop % Tolerances are not satisfied and the stop button 
            % has been pressed in the output function
   fprintf('\n Mesh adaption interrupted \n\n');
   y = y - err(:,1:bvpopt.Degree+1:end);
   ycol = ycol - err;
   
   feval(bvpopt.OutputFcn,tcol,ycol(bvpopt.OutputSel,:),bvpopt.Degree,'done');
   
   qTol = -1; % stop mesh adaption process   
end


%********************************************************************************
%************************* REFINE MESH BY FACTOR 1.5 ****************************
%********************************************************************************


function [new_tau,new_y] = refine_mesh_2_to_3(tau,y,islinear);

if mod(length(tau),2)  % even number of intervals
   [new_tau,new_y] = refine_mesh(tau(1:2:end), y(:,1:2:end), 3, islinear);
else                   % odd number of intervals, interpolate mesh distribution
                       % onto mesh with an even number.   
   N = length(tau)-1;
   
   tau_y = interp1(linspace(0,1,N+1)', [tau ; y]', linspace(0,1,N+2)','*linear');
   
   % ***** extract tau and y from the tau_y-matrix
   tau = tau_y(:,1)';
   y = tau_y(:,2:end)';
   
   % ***** proceed as in the case of an even number of intervals
   [new_tau,new_y] = refine_mesh(tau(1:2:end), y(:,1:2:end), 3, islinear);
end


%********************************************************************************
%************************ REFINE MESH BY FACTOR ratio ***************************
%********************************************************************************


function [new_tau,new_y] = refine_mesh(tau,y,ratio,islinear);

h = diff(tau);

% ***** insertion distribution
insert_dist = (0:ratio-1)/ratio;
    
tau_matrix = ones(ratio,1) * tau(1:end-1) + insert_dist' * h;

new_tau = [tau_matrix(:)'  tau(end)];


% ***** interpolate y onto new mesh
if ~islinear
   new_y = interp1q(tau',y',new_tau')';
else
   new_y = zeros(size(y,1) , size(tau,2));
end



%********************************************************************************
%******************************** LITTLE HELPERS ********************************
%********************************************************************************


function f = evaluate_f(bvpfile,t,bvpopt,parameters)
global N_ p_ d_

% ***** evaluate f(t,y) along the mesh
if bvpopt.fVectorized
   f = feval(bvpfile,'f',t,zeros(d_,length(t)),[],[],parameters{:});
else
   f = zeros(d_,length(t));   
   zero = zeros(d_,1);
   
   for l=1:length(t)
      f(:,l) = feval(bvpfile,'f',t(l),zero,[],[],parameters{:});
   end
end



function fprime = evaluate_fprime(bvpfile,t,bvpopt,parameters)
global d_
% ********** evaluate f'(t,y) along the mesh
if bvpopt.JacVectorized
   fprime = reshape( feval(bvpfile,'df/dy',t,[],[],[],parameters{:}) , d_ ,d_ , length(t) );
else
   fprime = zeros(d_,d_, length(t));
      
   for l=1:length(t)
      fprime(:,:,l) = feval(bvpfile,'df/dy',t(l),[],[],[],parameters{:});
   end
   
   reshape(fprime,d_,d_*length(t));
end




%********************************************************************************
%******************************** CHECK BVPFILE *********************************
%********************************************************************************


function check_bvpfile(bvpfile,tau,y0,bvpopt,parameters);

d = size(y0,1);

t1 = tau(1) + 0.1 * (tau(2)-tau(1));
tN = tau(end) -0.1 * (tau(end)-tau(end-1));

y1 = y0(:,1);
yN = y0(:,end);

% ***** Check f
try 
   f = feval(bvpfile,'f',t1,y1,0,0,parameters{:});
catch
   error([' Error in evaluating the right hand side f(t,y). Check the bvpfile ! ']);
end

if ~all(size(f)==size(y1))
   error([' y and f(t,y) do not match in dimension. Check the bvpfile ! ']);
end

if bvpopt.fVectorized
   try
      f = feval(bvpfile,'f',[t1 tN],[y1 yN],0,0,parameters{:});
      if size(f,2)~=2
         error([' The bvpfile is not properly f-vectorized.']);
      end
   catch
      error([' The bvpfile is not f-vectorized. Unset ''fVectorized'' in bvpopt.']);
   end
end

if bvpopt.JacVectorized
   try
      fprime = reshape( feval(bvpfile,'df/dy',[t1 tN],[y1 yN],0,0,parameters{:}) , d, d, 2);
      if any(size(fprime) - [d d 2]) 
         error([' The bvpfile is not properly Jacobian-vectorized.']);
      end
   catch
      error([' The bvpfile is not Jacobian-vectorized.  Unset ''JacVectorized'' in bvpopt.']);
   end
end


% ***** Check R
try 
   R = feval(bvpfile,'R',0,0,y1,yN, parameters{:});
catch
   error([' Error in evaluating the boundary conditions R(ya,yb). Check the bvpfile ! ']);
end

if ~all(size(R)==size(y1))
   error([' y and R(ya,yb) do not match in dimension. Check the bvpfile ! ']);
end


% ***** Check df/dy
try 
   df = feval(bvpfile,'df/dy',t1,y1,0,0,parameters{:});
catch
   error([' Error in evaluating the Jacobian df/dy. Check the bvpfile ! ']);
end

if ~all(size(df)==d)
   error([' y and df/dy do not match in dimension. Check the bvpfile ! ']);
end

% ***** Check dR/dya
try 
   dRdya = feval(bvpfile,'dR/dya',0,0,y1,yN,parameters{:});
catch
   error([' Error in evaluating the Jacobian dR/dya. Check the bvpfile !']);
end

if ~all(size(dRdya)==d)
   error([' y and dRdya do not match in dimension. Check the bvpfile !! ']);
end


% ***** Check dR/dyb
try 
   dRdyb = feval(bvpfile,'dR/dyb',0,0,y1,yN,parameters{:});
catch
   error([' Error in evaluating the Jacobian dR/dyb. Check the bvpfile ! ']);
end

if ~all(size(dRdyb)==d)
   error([' y and dRdyb do not match in dimension. Check the bvpfile ! ']);
end








%********************************************************************************
%************************** CHECK BVPFILE JACOBIANS *****************************
%********************************************************************************

function check_bvpfile_jacobians(bvpfile,tau,y0,bvpopt,parameters);
% checks if Jacobians in bvpfile match finite difference approximations

fprintf(' Check Jacobians ...\n');

t1 = tau(1) + 0.1 * (tau(2)-tau(1));
tN = tau(end) -0.1 * (tau(end)-tau(end-1));

y1 = y0(:,1);
yN = y0(:,end);
y1d = y1;     % perturbed y1, for finite difference approximation
yNd = yN;

%********************************* Check df/dy **********************************

f = feval(bvpfile,'f',t1,y1,0,0,parameters{:});
Dff = zeros(length(y1));
for j=1:length(y1)
   
   y1d(j)=y1(j) + 1e-8;
   
   Dff(:,j) = (feval(bvpfile,'f',t1,y1d,0,0,parameters{:}) - f) * 1e8;
   
   y1d(j)=y1(j);
end

Df = feval(bvpfile,'df/dy',t1,y1,0,0,parameters{:});

m=max(abs(Df(:)-Dff(:)));
normf = norm(f);

if ((normf ~= 0) & (m/normf > 1e-7)) | ((normf == 0) & (m > 1e-7))
   fprintf('\n WARNING ! Jacobian df/dy does not match finite difference approximation ! \n');
   fprintf(' df/dy - df/dy_finite_diff :\n\n');
   disp(Df-Dff);
else
   fprintf(' Maximum difference between Jacobian df/dy and finite difference \n');
   fprintf([' approximation is ' num2str(m) ' .\n']);
end


%********************************* Check dR/dy1 *********************************

R = feval(bvpfile,'R',0,0,y1,yN,parameters{:});
DRf = zeros(length(y1));
for j=1:length(y1)
   y1d(j)=y1(j) + 1e-4;
   DRf(:,j) = (feval(bvpfile,'R',0,0,y1d,yN,parameters{:}) - R) * 1e4;
   y1d(j)=y1(j);   
end

DR = feval(bvpfile,'dR/dya',0,0,y1,yN,parameters{:});

m=max(abs(DR(:)-DRf(:)));
normR = norm(R);

if ((normR ~= 0) & (m/normR > 1e-7)) | ((normR == 0) & (m > 1e-7))
   fprintf('\n WARNING ! Jacobian dR/dya does not match finite difference approximation ! \n');
   fprintf(' dR/dya - dR/dya_finite_diff :\n\n');
   disp(DR-DRf);
else
   fprintf(' Maximum difference between Jacobian dR/dya and finite difference \n');
   fprintf([' approximation is ' num2str(m) ' .\n']);
end


%********************************* Check dR/dyN *********************************

for j=1:length(y1)
   yNd(j)=yN(j) + 1e-4;
   DRf(:,j) = (feval(bvpfile,'R',0,0,y1,yNd,parameters{:}) - R) * 1e4;
   yNd(j)=yN(j);   
end

DR = feval(bvpfile,'dR/dyb',0,0,y1,yN,parameters{:});

m=max(abs(DR(:)-DRf(:)));
if ((normR ~= 0) & (m/normR > 1e-7)) | ((normR == 0) & (m > 1e-7))
   fprintf('\n WARNING ! Jacobian dR/dyb does not match finite difference approximation ! \n');
   fprintf(' dR/dyb - dR/dyb_finite_diff :\n\n');
   disp(DR-DRf);   
else
   fprintf(' Maximum difference between Jacobian dR/dyb and finite difference \n');
   fprintf([' approximation is ' num2str(m) ' .\n\n']);
end



%********************************************************************************
%********************** GET DEFAULT INITIAL APPROXIMATION ***********************
%********************************************************************************


function  y0 = get_default_initial_approximation(bvpfile,tau,bvpopt,parameters);

if bvpopt.Private.IsLinear
   DR = feval(bvpfile,'dR/dya',{},{},{},{},parameters{:});
else       % In the nonlinear case, we have to use trial and error
   
   success = 0;
   for i=1:100
      try
         DR = feval(bvpfile,'dR/dya',0,0,zeros(i,1),zeros(i,1),parameters{:});
         success = 1;
      end
      
      if success
         break;
      end      
   end
   
   if ~success  % the dimensions from 1 to 100 have been tried unsuccessfully
      error([' Could not determine the dimension of the system of diff. eq.'...
             ' Please check the bvpfile or provide an initial approximation.']);
   end
end

if bvpopt.Display & (~bvpopt.Private.IsLinear)
   fprintf(' Used default initial approximation (all zeros) \n'); 
end

% ***** default initial approximation
y0 = zeros(size(DR,1),length(tau));
